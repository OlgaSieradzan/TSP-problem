---
title: "Projekt Inteligencja Obliczeniowa"
author: "Justyna Sarkowicz, Olga Sieradzan, Weronika Duda, Amelia Madej, Aleksandra Węgrzyn"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: 
      collapsed: true
      smooth_scroll: true
    toc_font: "Arial"
    df_print: paged
---

<style>
  img {
    width: 100%;
    height: auto;
  }
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo=FALSE, include=FALSE, message=FALSE, warning=FALSE}
library(readxl)
library(ggplot2)
library(gridExtra)
library(psych)
library(patchwork)
library(dplyr)
library(tidyr)
```

# Wprowadzenie

<div style='text-align: justify'>
**Problem komiwojażera** (ang. Travelling Salesman Problem, TSP) to jedno z najbardziej znanych oraz intensywnie badanych zagadnień w dziedzinie optymalizacji kombinatorycznej oraz teorii grafów. W swojej klasycznej formie problem ten polega na znalezieniu najkrótszej możliwej trasy, która odwiedza dokładnie raz każdy z zadanych punktów i powraca do punktu początkowego. TSP znajduje zastosowanie w wielu dziedzinach, takich jak logistyka, planowanie tras, produkcja czy genetyka.

TSP jest problemem należącym do klasy NP-trudnych, co oznacza, że wraz ze wzrostem liczby punktów (miast) liczba możliwych tras rośnie w sposób wykładniczy, a dokładne rozwiązanie staje się coraz trudniejsze do obliczenia w rozsądnym czasie. Z tego powodu opracowanie efektywnych algorytmów heurystycznych i metaheurystycznych, które pozwalają na znalezienie bliskich optymalnym rozwiązań w akceptowalnym czasie.

Celem naszego projektu jest implementacja sześciu różnych algorytmów, które rozwiązują problem komiwojażera.
</div>

# Solver

<div style='text-align: justify'>
Wyniki uzyskane za pomocą zaimplementowanych algorytmów zostaną porównane z tymi uzyskanymi w Solverze. Będzie to nasz benchmark.
</div>

```{r, echo=FALSE, include=FALSE}
solver <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/Solver.xlsx")
#solver <- read_excel("C:/Users/user/Downloads/Solver.xlsx")
```

```{r, echo=FALSE}
solver[,c(2,4,6)]
```

<div style='text-align: justify'>
W przypadku danych TSP_48 czasy są tutaj dość zbliżone. Najniższy z nich to 92.625 s. Natomiast dla TSP_76 mamy dwie wartości znacząco odstające od pozostałych. Dla TSP_127 czasy są zdecydowanie najdłuższe w stosunku do pozostałych. Nie ma tam tak rozbieżnych wyników jak dla TSP_76. 
</div>

## Statystyki

W statystykach poniżej przedstawiono najkrótszą oraz najdłuższą długość ścieżki uzyskaną przez Solver. Mamy również wyciągniętą średnią ze wszystkich wyników.

```{r, echo=FALSE}
sol_tsp48 <- describe(solver$TSP_48)
sol_tsp76 <- describe(solver$TSP_76)
sol_tsp127 <- describe(solver$TSP_127)
sol <- rbind(sol_tsp48)
sol <- rbind(sol, sol_tsp76)
sol <- rbind(sol, sol_tsp127)
sol <- sol[ ,c("min", "max", "mean")]
rownames(sol) <- c("TSP_48", "TSP_76", "TSP_127")
sol
```

# Algorytmu Najbliższego Sąsiada (NN)

<div style='text-align: justify'>
**Algorytm najbliższego sąsiada** (ang. nearest neighbour algorithm, NN) jest prostym algorytmem służącym do rozwiązania prolemu komiwojażera. Jego celem jest znalezienie najkrótszej trasy, która przechodzi przez wszystkie miasta. Proces rozpoczyna się od wybranego miasta, a następnie w każdym kroku wybierane jest najbliższe miasto, które jeszcze nie zostało odwiedzone, do którego algorytm przechodzi. Po odwiedzeniu wszystkich miast algorytm kończy działanie i zwraca uzyskaną trasę.
</div>

## Badane parametry

W ramach algorytmu nalbliższego sąsiada badaniu poddano wpływ różnych wartości parametru `miasto startowe`.

<br>
```{r, echo=FALSE, include=FALSE}
 NN_tsp48 <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/NN.xlsx", 
     sheet = "TSP_48")
 NN_tsp76 <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/NN.xlsx", 
     sheet = "TSP_76")
 NN_tsp127 <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/NN.xlsx", 
     sheet = "TSP_127")

# NN_tsp48 <- read_excel("C:/Users/user/Downloads/NN.xlsx", 
#     sheet = "TSP_48")
# NN_tsp76 <- read_excel("C:/Users/user/Downloads/NN.xlsx", 
#     sheet = "TSP_76")
# NN_tsp127 <- read_excel("C:/Users/user/Downloads/NN.xlsx", 
#     sheet = "TSP_127")
```

```{r, echo=FALSE}
w_tsp48 <- ggplot(NN_tsp48, aes(x = Punkt, y = Wynik)) +
  geom_point(size = 2, position = position_jitter(width = 0.2), colour = "blue") +
  labs(
    title = "TSP_48",
    x = "Punkt początkowy",
    y = "Długość ścieżki"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 10, hjust = 0.5))

w_tsp76 <- ggplot(NN_tsp76, aes(x = Punkt, y = Wynik)) +
  geom_point(size = 2, position = position_jitter(width = 0.2), colour = "blue") +
  labs(
    title = "TSP_76",
    x = "Punkt początkowy",
    y = "Długość ścieżki"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 10, hjust = 0.5))

w_tsp127 <- ggplot(NN_tsp127, aes(x = Punkt, y = Wynik)) +
  geom_point(size = 2, position = position_jitter(width = 0.2), colour = "blue") +
  labs(
    title = "TSP_127",
    x = "Punkt początkowy",
    y = "Długość ścieżki"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 10, hjust = 0.5))

(w_tsp48 + w_tsp76 + w_tsp127 + guide_area()) +
  plot_layout(guides = "collect") +  
  plot_annotation(title = "Długość ścieżki w zależności od punktu startowego",
                  theme = theme(
      plot.title = element_text(size = 14, face = "bold", hjust = 0.5)))
```

Na wykresach widzimy długość trasy w zależności od punktu startowego. Punkt startowy to miasto, z którego zaczynamy szukać najkrótszej trasy. Z wykresów nie da się wiele wyciągnąć, nie ma tutaj żadnej zależności. Widzimy jednak, że wybór punktu początkowego, z którego zaczyna algorytm ma znaczenie.

```{r echo=FALSE, include=FALSE}
stat_NN_tsp48 <- describe(NN_tsp48$Wynik)
stat_NN_tsp76 <- describe(NN_tsp76$Wynik)
stat_NN_tsp127 <- describe(NN_tsp127$Wynik)
stat_NN <- rbind(stat_NN_tsp48)
stat_NN <- rbind(stat_NN, stat_NN_tsp76)
stat_NN <- rbind(stat_NN, stat_NN_tsp127)
stat_NN <- stat_NN[ ,c("min", "max", "mean")]
rownames(stat_NN) <- c("TSP_48", "TSP_76", "TSP_127")
stat_NN
```

W tabelce widzimy najkrótsze ścieżki otrzymane dla poszczególnych TSP.

* **TSP_48**

```{r, echo=FALSE}
NN_tsp48_punkt <- NN_tsp48$Punkt[NN_tsp48$Wynik == min(NN_tsp48$Wynik)]
NN_tsp48[c(10,35),]
```

Długość ścieżki wyniosła **12012** i jest to gorszy wynik od Solvera o **1144**. Średni wynik również jest gorszy. Ten wynik został uzyskany dla 2 punktów początkowych: 10 i 35.

* **TSP_76**

```{r, echo=FALSE}
NN_tsp76_punkt <- NN_tsp76$Punkt[NN_tsp76$Wynik == min(NN_tsp76$Wynik)]
NN_tsp76[16,]
```

Długość ścieżki wyniosła **130921** i jest to gorszy wynik od Solvera o **12627.5**. Średni wynik również jest gorszy. Wynik ten udało się uzyskać dla punktu początkowego 16.

* **TSP_127**

```{r, echo=FALSE}
NN_tsp127_punkt <- NN_tsp127$Punkt[NN_tsp127$Wynik == min(NN_tsp127$Wynik)]
NN_tsp127[117,]
```

Długość ścieżki wyniosła **133970.6** i jest to lepszy wynik od Solvera o **6247**. Średni wynik tutaj też jest gorszy. Wynik ten udało się uzyskać dla punktu początkowego 117.

Za pomocą tego algorytmu nie udało się uzyskać lepszych wyników niż Solver dla TSP_48 i TSP_76.

# Algorytm wspinaczki z multistartem (IHC)

<div style='text-align: justify'>
**Algorytm iteracyjnej wspinaczki** to technika optymalizacyjna, stosowana do znajdowania zbliżonych do optymalnych rozwiązań problemów, które mogą mieć wiele lokalnych minimów. Wykorzystuje on podejście algorytmu wspinaczki, rozszerzone o wielokrotne losowanie różnych początkowych rozwiązań, co zwiększa szansę na znalezienie 
rozwiązania bliskiego globalnemu optimum.
</div>

<<<<<<< HEAD
## Badane parametry


W ramach algorytmu iteracyjnej wspinaczki badane są następujące parametry:

 - **`liczba punktów początkowych`** - maksymalna liczba losowych punktów początkowych, z których algorytm rozpoczyna wspinaczkę
 
 - **`rodzaj sąsiedztwa`** - metoda generowania nowych rozwiązań na podstawie aktualnego rozwiązania. W badaniu uwzględniono typy:
 
    - **`swap`** nowe rozwiązanie powstaje poprzez zamianę miejscami dwóch miast w bieżącej trasie
    
    - **`insertion`** polega na wyborze jednego miasta z danej trasy, usunięciu go z jego pierwotnej pozycji, a następnie wstawieniu go w inne, wybrane miejsce w tej samej trasie
    
    - **`2-opt`** wiąże się z odwróceniem segmentu trasy między dwoma wybranymi wierzchołkami, co prowadzi do zmiany kolejności miast w tym segmencie
  
    <p style="margin-top: 10px;">
 - **`limit czasowy`** - czas, jaki posiada algorytm na znalezienie rozwiązania
 
 - **`liczba iteracji bez poprawy`** - liczba iteracji, po której algorytm kończy działanie, jeśli nie znaleziono lepszego rozwiązania
 
 - **`liczba iteracji wspinaczki`** - liczba iteracji, jaką algorytm może wykonać w jednej próbie wspinaczki
    </p>


=======
>>>>>>> d2d616ca7c243c7370a932c94612a3612908bc57

```{r}
IHC_clasic <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/IHC.xlsx", 
    sheet = "Basic")
IHC_max_iterations <- read_excel("C:/Users/Justyna/Desktop/IHC.xlsx", 
    sheet = "num_starts")
IHC_move_type <- read_excel("C:/Users/Justyna/Desktop/IHC.xlsx", 
    sheet = "neighborhood_type")
##IHC_max_hill_climbing_iterations <- read_excel("C:/Users/Justyna/Desktop/IHC.xlsx", 
##    sheet = "max_hill_climbing_iterations")
IHC_max_iterations_without_improvement <- read_excel("C:/Users/Justyna/Desktop/IHC.xlsx", 
    sheet = "max_iterations_without_improvem")
IHC_time_limit <- read_excel("C:/Users/Justyna/Desktop/IHC.xlsx",
   sheet = "time_limit")
```

## Klasyczny

Za podstawowe dane przyjmujemy:

* num_starts = 100, 

* neighborhood_type = "two-opt", 

* time_limit = 500, 

* max_iterations_without_improvement = 100, 

* max_hill_climbing_iterations = 1000.

```{r, echo=FALSE}
IHC_clasic_tsp48 <- IHC_clasic %>%
  filter(DATASET == "DATA1") %>%
  select(WYNIK) %>%
  as.data.frame()

IHC_clasic_tsp76 <- IHC_clasic %>%
  filter(DATASET == "DATA2") %>%
  select(WYNIK) %>%
  as.data.frame()

IHC_clasic_tsp127 <- IHC_clasic %>%
  filter(DATASET == "DATA3") %>%
  select(WYNIK) %>%
  as.data.frame()

IHC_clasic_wyniki <- cbind(IHC_clasic_tsp48)
IHC_clasic_wyniki <- cbind(IHC_clasic_wyniki, IHC_clasic_tsp76)
IHC_clasic_wyniki <- cbind(IHC_clasic_wyniki, IHC_clasic_tsp127)

colnames(IHC_clasic_wyniki) <- c("TSP_48", "TSP_76", "TSP_127")
IHC_clasic_wyniki
```

```{r, echo=FALSE}
IHC_clasic_stat <- IHC_clasic %>%
  group_by(DATASET) %>%
  summarise(
    Mean = mean(WYNIK),
    Min = min(WYNIK),
    Max = max(WYNIK)
  ) %>%
  as.data.frame()              

rownames(IHC_clasic_stat) <- c("TSP_48", "TSP_76", "TSP_127")

IHC_clasic_stat[,c("Min", "Max", "Mean")]
```

Powyżej w tabelkach możemy zobaczyć uzyskane wyniki dla algorytmu iteracyjnej wspinaczki oraz minimalną, maksymalną i średnią wartość. Uzyskane wyniki są bardzo dobre. Średnie w każdym z przypadku są o wiele niższe niż te uzyskane przez Solver.

**Czas**

```{r, echo=FALSE, warning=FALSE, message=FALSE}
IHC_clasic_time <- IHC_clasic %>%
  group_by(DATASET) %>%
  select(CZAS) %>%
  summarise(
    Min = min(CZAS),
    Max = max(CZAS),
    Mean = mean(CZAS)
  ) %>% 
  as.data.frame()
  
rownames(IHC_clasic_time) <- c("TSP_48", "TSP_76", "TSP_127")

IHC_clasic_time[,2:4]
```

Średnie czas są dość niskie dla TS_48 i TSP_76. Natomiast dla TSP_127 średni czas wynosi już ok. 2 minut.

## Liczba iteracji

Poniżej zbadany został wpływ liczby iteracji na długość ścieżki:

```{r, echo=FALSE}
IHC_max_iterations_tsp48 <- IHC_max_iterations %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

IHC_max_iterations_tsp76 <- IHC_max_iterations %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

IHC_max_iterations_tsp127 <- IHC_max_iterations %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(IHC_max_iterations_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Liczba iteracji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
IHC_max_iterations_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Mediana i średnie wahają się w zależności od liczby iteracji wokół podobnych wartości. Nie widać żadnej zależności. 

```{r, echo=FALSE}
ggplot(IHC_max_iterations_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Liczba iteracji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
IHC_max_iterations_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Tutaj analogiczna sytuacja. Średnie są natomiast bardzo niskie w porównaniu do Solvera.

```{r, echo=FALSE}
ggplot(IHC_max_iterations_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Liczba iteracji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
IHC_max_iterations_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_127 pojawia się taka sama sytuacja.

W żadnym z przypadków nie widac, żadnej zależności. Jednak różnice w liczbie parametrów są dość małe. Możliwe, że sprawdzenie większej liczby iteracji pokazałoby jakąś zależność.

## Rodzaj sąsiedztwa

Poniżej zbadany został wpływ rodzaju sąsiedztwa na długość ścieżki:

```{r, echo=FALSE}
IHC_move_type_tsp48 <- IHC_move_type %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

IHC_move_type_tsp76 <- IHC_move_type %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

IHC_move_type_tsp127 <- IHC_move_type %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(IHC_move_type_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Typ ruchu",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
IHC_move_type_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Rodzaj sąsiedztwa zdecydowanie wpływa na długości ścieżki. Mediana i średnia są najniższe w przypadku `two-opt`. Natomiast najgorsze wyniki są dla `swap`.

```{r, echo=FALSE}
ggplot(IHC_move_type_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Typ ruchu",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
IHC_move_type_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Tutaj jest bardzo podobna sytuacja. Dla `insetion` wyniki nie są najgorsze. Jednak jest dość znacząca różnica między nimi a `two-opt`.

```{r, echo=FALSE}
ggplot(IHC_move_type_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Typ ruchu",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
IHC_move_type_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_127 jest identyczna sytuacja co w poprzednich TSP.

Długość ścieżki definitywnie zależy od rodzaju ruchu. Dla `two-opt` w każdym z przypadków wyniki są najlepsze. Natomiast dla `swap` najgorsza.

## Limit czasowy

Poniżej zbadany został wpływ rodzaju sąsiedztwa na długość ścieżki:

```{r, echo=FALSE}
IHC_time_limit_tsp48 <- IHC_time_limit %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

IHC_time_limit_tsp76 <- IHC_time_limit %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

IHC_time_limit_tsp127 <- IHC_time_limit %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(IHC_time_limit_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Limit czasowy",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
IHC_time_limit_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame()
```

Dla TSP_48 limit czasowy nie wydaje się wpływać na długość ścieżki. Średnie i mediany dla każdego parametru są dość zbliżone do siebie.

```{r, echo=FALSE}
ggplot(IHC_time_limit_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Limit czasowy",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
IHC_time_limit_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame()
```

Natomiast tutaj widzimy, że mediana i średnia długośći ścieżki maleją wraz ze wzrostem limitu czasowego. Jednak największy spadek jest na początku, później już te różnice są niewielkie.

```{r, echo=FALSE}
ggplot(IHC_time_limit_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Limit czasowy",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
IHC_time_limit_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame()
```

Dla TSP_127 widać już jednak zdecydowanie malejącą średnią i mediane wraz ze wzrostem limitu czasowego. 

Jedynie dla TSP_127 pojawiła się zależność, że wraz ze wzrostem limitu czasowego, maleje długość ścieżki. Może być to związane z tym, że tutaj liczba miast jest największa, więc znalezienie lepszych tras wymaga większego limitu czasowego w porównaniu do pozostałych.

## Liczba iteracji bez poprawy

Poniżej zbadany został wpływ liczby iteracji bez poprawy na długość ścieżki:

```{r, echo=FALSE}
IHC_max_iterations_without_improvement_tsp48 <- IHC_max_iterations_without_improvement %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

IHC_max_iterations_without_improvement_tsp76 <- IHC_max_iterations_without_improvement %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

IHC_max_iterations_without_improvement_tsp127 <- IHC_max_iterations_without_improvement %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(IHC_max_iterations_without_improvement_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Liczba iteracji bez poprawy",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
IHC_max_iterations_without_improvement_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Mediana i średnia są dość zbliżone dla każdej wartości parametru. Nie widać tutaj znaczących różnic.

```{r, echo=FALSE}
ggplot(IHC_max_iterations_without_improvement_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Liczba iteracji bez poprawy",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
IHC_max_iterations_without_improvement_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_76 pojawia się podobna sytuacja. W jednym z przypadków natomiast średnia i mediana są wyższe. Natomiast nie widać żadnej zależności.

```{r, echo=FALSE}
ggplot(IHC_max_iterations_without_improvement_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Liczba iteracji bez poprawy",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
IHC_max_iterations_without_improvement_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Tutaj natomiasst widzimy pod koniec wzrost mediany i średniej, który nie był widoczny wcześniej.

Nie widać tutaj, aby jakaś zależność się pojawiała. Ogólnie rzecz biorąc w każdym przypadku mediana i średnia zachowują się podobnie z pewnymi odstępstwami.

## Liczba iteracji wspinaczki

Poniżej zbadany został wpływ liczby iteracji wspiczanki na długość ścieżki:

```{r, echo=FALSE}
# IHC_max_hill_climbing_iterations_tsp48 <- IHC_max_hill_climbing_iterations %>%
#   filter(DATASET == "DATA1") %>%
#   as.data.frame()
# 
# IHC_max_hill_climbing_iterations_tsp76 <- IHC_max_hill_climbing_iterations %>%
#   filter(DATASET == "DATA2") %>%
#   as.data.frame()
# 
# IHC_max_hill_climbing_iterations_tsp127 <- IHC_max_hill_climbing_iterations %>%
#   filter(DATASET == "DATA3") %>%
#   as.data.frame()
```

```{r, echo=FALSE}
# ggplot(IHC_max_hill_climbing_iterations_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
#   geom_boxplot(fill = "pink") +
#   labs(
#     title = "TSP_48",
#     x = "Liczba iteracji wspinaczki",
#     y = "Długość ścieżki"
#   ) +
#   theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
# IHC_max_hill_climbing_iterations_tsp48 %>%
#   group_by(PARAMETR) %>%
#   summarise(
#     Min = min(WYNIK_1),
#     Max = max(WYNIK_1),
#     Mean = mean(WYNIK_1)
#   ) %>%
#   as.data.frame() 
```

```{r, echo=FALSE}
# ggplot(IHC_max_hill_climbing_iterations_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
#   geom_boxplot(fill = "pink") +
#   labs(
#     title = "TSP_76",
#     x = "Liczba iteracji wspinaczki",
#     y = "Długość ścieżki"
#   ) +
#   theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
# IHC_max_hill_climbing_iterations_tsp76 %>%
#   group_by(PARAMETR) %>%
#   summarise(
#     Min = min(WYNIK_1),
#     Max = max(WYNIK_1),
#     Mean = mean(WYNIK_1)
#   ) %>%
#   as.data.frame() 
```

```{r, echo=FALSE}
# ggplot(IHC_max_hill_climbing_iterations_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
#   geom_boxplot(fill = "pink") +
#   labs(
#     title = "TSP_127",
#     x = "Liczba iteracji wspinaczki",
#     y = "Długość ścieżki"
#   ) +
#   theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
# IHC_max_hill_climbing_iterations_tsp127 %>%
#   group_by(PARAMETR) %>%
#   summarise(
#     Min = min(WYNIK_1),
#     Max = max(WYNIK_1),
#     Mean = mean(WYNIK_1)
#   ) %>%
#   as.data.frame() 
```

## Podsumowanie

Najlepszy wyniki dla TSP_48 przy zmianie poszczególnych parametrów:

* Klasyk - 	10713.0

* Liczba iteracji - 10695 (liczba iteracji - 125)

* Rodzaj sąsiedztwa - 10700 (rodzaj sąsiedztwa - two-opt)

* Limit czasowy - 10692	 (limit czasowy - 200)

* Liczba iteracji bez poprawy  -  10695 (liczba iteracji bez poprawy - 50)

* Liczba iteracji wspinaczki - 	(liczba iteracji wspinaczki - )

Dla TSP_48 przy użyciu algorytmu symulowanego wyżarzania udało się uzyskać pare lepszych wyników niż ten uzyskany przez Solver (10868).

Najlepszy wyniki dla TSP_76 przy zmianie poszczególnych parametrów:

* Klasyk - 	110039.7

* Liczba iteracji - 109207.4 (liczba iteracji - 125)

* Rodzaj sąsiedztwa - 109661.0 (rodzaj sąsiedztwa - two-opt)

* Limit czasowy - 109058.3 (limit czasowy - 1000)

* Liczba iteracji bez poprawy  - 108942.2 (liczba iteracji bez poprawy - 50)

* Liczba iteracji wspinaczki - 	(liczba iteracji wspinaczki - )

Dla TSP_76 przy użyciu algorytmu symulowanego wyżarzania również udało się uzyskać sporo zdecydowanie lepszych wyników niż ten uzyskany przez Solver (118293.5)

Najlepszy wyniki dla TSP_127 przy zmianie poszczególnych parametrów:

* Klasyk - 	122191.3

* Liczba iteracji - 119515.0 (liczba iteracji - 125)

* Rodzaj sąsiedztwa - 121017.9 (rodzaj sąsiedztwa - two-opt) 

* Limit czasowy - 119118.3 (limit czasowy - 1400)

* Liczba iteracji bez poprawy  - 120208.5 (liczba iteracji bez poprawy - 50)

* Liczba iteracji wspinaczki - 	(liczba iteracji wspinaczki - )

Dla TSP_127 przy użyciu algorytmu symulowanego wyżarzania nie udało się uzyskać lepsze wyniki niż ten uzyskany przez Solver (140217.6). 

# Algorytm symulowanego wyżarzania (SA)

<div style='text-align: justify'>
**Algorytm symulowanego wyżarzania** (ang. Simulated Annealing, SA) jest iteracyjną metodą optymalizacji, która rozpoczyna się od losowego rozwiązania i w każdej iteracji wprowadza zmiany w obrębie sąsiedztwa. Inspiracją dla algorytmu SA był proces metalurgiczny, w którym metal w wysokich temperaturach łatwiej poddaje się obróbce plastycznej. W miarę obniżania temperatury, zmiany kształtu stają się coraz trudniejsze. Podobnie, w algorytmie symulowanego wyżarzania na początku akceptowane są ruchy prowadzące do gorszych rozwiązań z relatywnie dużym prawdopodobieństwem, gdy temperatura jest wysoka. Z upływem iteracji oraz spadkiem temperatury, prawdopodobieństwo akceptacji gorszych rozwiązań maleje, co skutkuje tym, że algorytm niemal zawsze odrzuca pogarszające ruchy. Mechanizm ten ma na celu unikanie utknięcia w ekstremach lokalnych. W każdej iteracji generowane są losowe ruchy, a ich liczba jest 
parametryzowana w danej implementacji. 
</div>

## Badane parametry

W ramach algorytmu symulowanego wyżarzania badane są następujące parametry:

 - **`temperatura początkowa`** -  wartość temperatury, od której rozpoczyna się proces chłodzenia w algorytmie
 
 - **`temperatura końcowa`** - wartość temperatury, do której algorytm będzie dążył w trakcie działania
 
 - **`rodzaj sąsiedztwa`** - metoda generowania nowych rozwiązań na podstawie aktualnego rozwiązania. W badaniu uwzględniono typy:
 
    - `swap` nowe rozwiązanie powstaje poprzez zamianę miejscami dwóch miast w bieżącej trasie
    
    - `insertion` polega na wyborze jednego miasta z danej trasy, usunięciu go z jego pierwotnej pozycji, a następnie wstawieniu go w inne, wybrane miejsce w tej samej trasie
    
    - `2-opt` wiąże się z odwróceniem segmentu trasy między dwoma wybranymi wierzchołkami, co prowadzi do zmiany kolejności miast w tym segmencie
  
    <p style="margin-top: 10px;">
 - **`czas działania`** - limit czasu, jaki posiada algorytm na znalezienie rozwiązania
 
 - **`prędkość chłodzenia`** -  szybkość, z jaką zmniejszana jest temperatura w trakcie działania algorytmu
 
 - **`temperatura minimalna`** - wartość temperatury, poniżej której algorytm nie będzie już kontynuował poszukiwań
    </p>
    
```{r echo=FALSE, include=FALSE}
# SA_compare_methods <- read_excel("C:/Users/user/Downloads/SA.xlsx", 
#     sheet = "Porównanie_metod")
# SA_max_iterations <- read_excel("C:/Users/user/Downloads/SA.xlsx", 
#     sheet = "max_iterations")
# SA_min_temp <- read_excel("C:/Users/user/Downloads/SA.xlsx", 
#     sheet = "min_tem")
# SA_cooling_rate <- read_excel("C:/Users/user/Downloads/SA.xlsx", 
#     sheet = "cooling_rate")
# SA_initial_temp <- read_excel("C:/Users/user/Downloads/SA.xlsx", 
#     sheet = "initial_temp")

SA_clasic <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/SA.xlsx", 
    sheet = "Basic")
SA_move_type <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/SA.xlsx", 
    sheet = "move_type")
SA_initial_temp <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/SA.xlsx", 
    sheet = "initial_temperature")
SA_cooling_rate <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/SA.xlsx", 
    sheet = "cooling_rate")
SA_max_iterations <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/SA.xlsx", 
    sheet = "max_iterations")
SA_min_temp <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/SA.xlsx", 
    sheet = "min_temperature")
```

## Klasyczne

Za podstawowe dane przyjmujemy :

* initial_temperature = 10000

* cooling_rate = 0.99

* max_iterations = 10000

* min_temperature = 1e-100

* time_limit = `None`

* move_type = `two_opt`

```{r, echo=FALSE}
SA_clasic_tsp48 <- SA_clasic %>%
  filter(DATASET == "DATA1") %>%
  select(WYNIK) %>%
  as.data.frame()

SA_clasic_tsp76 <- SA_clasic %>%
  filter(DATASET == "DATA2") %>%
  select(WYNIK) %>%
  as.data.frame()

SA_clasic_tsp127 <- SA_clasic %>%
  filter(DATASET == "DATA3") %>%
  select(WYNIK) %>%
  as.data.frame()

SA_clasic_wyniki <- cbind(SA_clasic_tsp48)
SA_clasic_wyniki <- cbind(SA_clasic_wyniki, SA_clasic_tsp76)
SA_clasic_wyniki <- cbind(SA_clasic_wyniki, SA_clasic_tsp127)

colnames(SA_clasic_wyniki) <- c("TSP_48", "TSP_76", "TSP_127")
SA_clasic_wyniki
```

```{r, echo=FALSE}
SA_clasic_stat <- SA_clasic %>%
  group_by(DATASET) %>%
  summarise(
    Mean = mean(WYNIK),
    Min = min(WYNIK),
    Max = max(WYNIK)
  ) %>%
  as.data.frame()              

rownames(SA_clasic_stat) <- c("TSP_48", "TSP_76", "TSP_127")

SA_clasic_stat[,c("Min", "Max", "Mean")]
```

Powyżej w tabelkach możemy zobaczyć uzyskane wyniki dla algorytmu symulowanego wyżarzania oraz minimalną, maksymalną i średnią wartość. Dla TSP_48 wyniki są zbliżone do tych z Solvera. Dla TSP_127 minimalna wartość jest trochę wyższa. Natomiast dla TSP_76 minimalna wartośc jest zdecydowanie lepsza, jak również średnia.

```{r, echo=FALSE, warning=FALSE, message=FALSE}
SA_clasic_time <- SA_clasic %>%
  group_by(DATASET) %>%
  select(CZAS) %>%
  summarise(
    Min = min(CZAS),
    Max = max(CZAS),
    Mean = mean(CZAS)
  ) %>% 
  as.data.frame()
  
rownames(SA_clasic_time) <- c("TSP_48", "TSP_76", "TSP_127")

SA_clasic_time[,2:4]
```

Uzyskane czasy przy podstawowych parametrach są bardzo niskie, nie wynoszą nawet sekundy. W Solverze były one zdecydowanie wyższe. w każdym  z przypadków.

## Rodzaj ruchu

Poniżej zbadany został wpływ rodzaju ruchu na długość ścieżki:

```{r, echo=FALSE}
SA_move_type_tsp48 <- SA_move_type %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

SA_move_type_tsp76 <- SA_move_type %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

SA_move_type_tsp127 <- SA_move_type %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(SA_move_type_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Typ ruchu",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
SA_move_type_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Widzimy, że sposób w jaki generujemy sąsiadów a algorytmie ma tutaj duże znaczenie. Wyniki są najgorsze w przypadku `swap` - średnia jest wysoka. Natomiast mediana i średnia długości ścieżki są najniższe w przypadku ruchu `2-opt`. Wyniki dla `2-opt` charakteryzują się małą wariancją (rozkład jest wąski), co wskazuje na niewielkie różnice w długościach ścieżek.

```{r, echo=FALSE}
ggplot(SA_move_type_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Typ ruchu",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
SA_move_type_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_76 pojawiła się analogiczna sytuacja. Dla `2-opt` wyniki są najlepsze. Uzyskana minimalna długość ścieżki, dla tej wartości parametru jest znacząco lepsza od Solvera (118293.5). Ponownie najgorzej wypada `swap`. Średnie się różnią znacząco w zależności od typu ruchu.

```{r, echo=FALSE}
ggplot(SA_move_type_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Typ ruchu",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
SA_move_type_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Tutaj sytuacja analogiczna. Wyniki są słabe dla `insertion` i `swap`. Natomiast dla `2-opt` już nie ma lepszych wyników niż w przypadku Solvera.

Jest tu dobrze widoczna zależność, że najkrótsza średnia i mediana długości ścieżki są w przypadku typu ruchu `2-opt`. Dla tej wartości parametru wariancja jest również w każdym z przypadków najmniejsza. Parametry `swap` i `insertion` nie działają tak efektywnie jak `2-opt`.

## Temperatura początkowa

Poniżej zbadany został wpływ temperatury początkowej na długość ścieżki:

```{r, echo=FALSE}
SA_initial_temp_tsp48 <- SA_initial_temp %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

SA_initial_temp_tsp76 <- SA_initial_temp %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

SA_initial_temp_tsp127 <- SA_initial_temp %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(SA_initial_temp_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Temperatura początkowa",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
SA_initial_temp_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Z wykresów pudełkowych nie widać żadnej zależności. Mediana i średnia długości ścieżki wahają się na podobnym poziomie dla różnych wartości parametru. Temperatura początkowa wydaję się nie mieć dużego wpływu.

```{r, echo=FALSE}
ggplot(SA_initial_temp_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Temperatura początkowa",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
SA_initial_temp_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_76 pojawiają się już większe wahania na początku, ale nadal dla nie widać, żeby w zależności od temperatury mediana długości ścieżki się znacząco zmieniała. Nie mamy tutaj też bardzo dużych odstępstw tzn. średnie i mediany są dość zbliżone do siebie. Otrzymane wyniki są bardzo dobre i zdecydowanie lepsze od tych z Solvera.

```{r, echo=FALSE}
ggplot(SA_initial_temp_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Temperatura początkowa",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
SA_initial_temp_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_127 mediana i średnia długości ścieżki rosną. Następnie pojawia się spadek i ponownie wzrost. Nie można jednak powiedzieć, że tak będzie za każdym razem. Należałoby sprawdzić większą liczbę parametrów. Wyniki jednak dalej są dość słabe.

Wpływ początkowej temperatury nie wydaje się być duży. 

## Prędkość chłodzenia

Poniżej zbadany został wpływ prędkości chłodzenia na długość ścieżki:

```{r, echo=FALSE}
SA_cooling_rate_tsp48 <- SA_cooling_rate %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

SA_cooling_rate_tsp76 <- SA_cooling_rate %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

SA_cooling_rate_tsp127 <- SA_cooling_rate %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(SA_cooling_rate_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Prędkość chłodzenia",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
SA_cooling_rate_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Z wykresu bardzo dobrze widać jak mediana długości ścieżki maleje wraz ze wzrostem prędkości chłodzenia. Średnia również wykazuje takie zachowanie. Jednak pod koniec nie mediana i średnia długości ścieżki nie maleją tak szybko, stają się wręcz zbliżone (0.94-0.98). 

```{r, echo=FALSE}
ggplot(SA_cooling_rate_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Prędkość chłodzenia",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
SA_cooling_rate_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_76 pojawiła się analogiczna sytuacja. Wraz ze wzrostem prędkości chłodzenia maleje mediana i średnia długości ścieżki. 

```{r, echo=FALSE}
ggplot(SA_cooling_rate_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Prędkość chłodzenia",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
SA_cooling_rate_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

W tym przypadku sytuacja jest identyczna.

We wszystkich przypadkach średnia i mediana długości ścieżki maleje wraz ze wzrostem prędkości chłodzenia. Może tak być dlatego, że temperatura szybciej spada do wartości minimalnej, więc algorytm spędza mniej czasu na eksplorowaniu gorszych rozwiązań. W rezultacie szybciej zbliża się do lokalnego minimum, co skutkuje krótszymi rozwiązaniami, ponieważ algorytm nie oddala się zbytnio od bieżącego rozwiązania.

## Liczba iteracji

Poniżej zbadany został wpływ liczby iteracji na długość ścieżki:

```{r, echo=FALSE}
SA_max_iterations_tsp48 <- SA_max_iterations %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

SA_max_iterations_tsp76 <- SA_max_iterations %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

SA_max_iterations_tsp127 <- SA_max_iterations %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(SA_max_iterations_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Liczba iteracji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
SA_max_iterations_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

DLa TSP_48 z wykresów dobrze widać, że wraz ze wzrostem liczby iteracji, maleje mediana i średnia długości ścieżki. Na początku maleją dość szybko, natomiast później następuje spowolnienie. Dla bardzo wysokich wartości parametrów nie widać już znaczących różnic w wynikach.

```{r, echo=FALSE}
ggplot(SA_max_iterations_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Liczba iteracji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
SA_max_iterations_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Tutaj pojawia się podobna sytuacja. Jednak w tym przypadku mediana i średnia dłużej maleją. Dopiero dla liczby iteracji = 6000 (dla TSP_48 = 4000), wartości statystyk stają sie do siebie zbliżone.

```{r, echo=FALSE}
ggplot(SA_max_iterations_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Liczba iteracji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
SA_max_iterations_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Analogicznie dla TSP_127. Wraz ze wzrostem liczby iteracji, maleje średnia i mediana długości ścieżki. Jednak robi to jeszcze wolniej niż w poprzednich przypadkach. Dopiero dla liczby iteracji = 8000 statysyki się wahają wokół podobnych wartości.

We wszystkich sytuacjach widać, że wraz ze wzrostem liczby iteracji, maleje mediana i średnia długośći ścieżki. Jednakże w pewnym momencie, różnym w zależności od liczby miast w problemie, osiągane wyniki przestają się znacząco różnić. Oznacza to, że algorytm stabilizuje się i zaczyna zbliżać się do swojego optimum. Dalsze zwiększanie liczby iteracji prowadzi jedynie do minimalnych zmian w wynikach, więc nie ma większego sensu.

## Minimalna temperatura

Poniżej zbadany został wpływ minimalnej temperatury na długość ścieżki:

```{r, echo=FALSE}
SA_min_temp_tsp48 <- SA_min_temp %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

SA_min_temp_tsp76 <- SA_min_temp %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

SA_min_temp_tsp127 <- SA_min_temp %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(SA_min_temp_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Minimalna temperatura",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
SA_min_temp_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Wraz ze wzrostem wartości temperatury minimimalnej mediana i średnia rosną. Zbyt duża minimalna temperatura początkowa powoduje, że algorytm kończy działanie zanim zdoła osiągnąć najlepsze możliwe rozwiązania. W efekcie pozostaje na gorszych ścieżkach, co powoduje wzrost mediany i średniej długości.

```{r, echo=FALSE}
ggplot(SA_min_temp_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Minimalna temperatura",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
SA_min_temp_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Tutaj pojawia się podobna sytuacja. Wraz ze wzrostem wartości minimalnej, wyniki są coraz gorsze.

```{r, echo=FALSE}
ggplot(SA_min_temp_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Minimalna temperatura",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
SA_min_temp_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_127 sytuacja jest analogiczna.

Widoczna jest zależność, że wraz ze wzrostem wartości minimalnej, median i średnia długość ścieżki maleją.

## Podsumowanie

Najlepszy wyniki dla TSP_48 przy zmianie poszczególnych parametrów:

* Klasyk - 11100.0		

* Rodzaje ruchów - 10928 (rodzaj ruchu - 2-opt)

* Temperatura początkowa - 10866 (temperatura początkowa - 100 tys.)

* Prędkość chłodzenia - 10875 (prędkość chłodzenia - 0.93)

* Liczba iteracji  - 10811 (liczba iteracji - 8000)

* Minimalna temperatura - 10862	(minimalna temperatura - 1e-40)

Dla TSP_48 przy użyciu algorytmu symulowanego wyżarzania udało się uzyskać pare lepszych wyników niż ten uzyskany przez Solver (10868).

Najlepszy wyniki dla TSP_76 przy zmianie poszczególnych parametrów:

* Klasyk - 116708.4	

* Rodzaje ruchów - 113460.2 (rodzaj ruchu - 2-opt)

* Temperatura początkowa - 113094.6 (temperatura początkowa - 50 tys.)

* Prędkość chłodzenia - 114398.9 (prędkość chłodzenia - 0.97)

* Liczba iteracji  -  113809.8 (liczba iteracji - 9000)

* Minimalna temperatura - 112768.6	(minimalna temperatura - 1e-60)

Dla TSP_76 przy użyciu algorytmu symulowanego wyżarzania również udało się uzyskać sporo zdecydowanie lepszych wyników niż ten uzyskany przez Solver (118293.5)

Najlepszy wyniki dla TSP_127 przy zmianie poszczególnych parametrów:

* Klasyk - 147496.4	

* Rodzaje ruchów - 148832.8 (rodzaj ruchu - 2-opt)

* Temperatura początkowa - 146215.7 (temperatura początkowa - 10 tys.)

* Prędkość chłodzenia - 143162.3 (prędkość chłodzenia - 0.98)

* Liczba iteracji  - 148956.7 (liczba iteracji - 8000)

* Minimalna temperatura - 147347.1	(minimalna temperatura - 1e-50)

Dla TSP_127 przy użyciu algorytmu symulowanego wyżarzania nie udało się uzyskać lepsze wyniki niż ten uzyskany przez Solver (140217.6). 

# Algorytm przeszukiwania tabu

<div style='text-align: justify'>
**Algorytm przeszukiwania tabu** (ang. Tabu Search, TS) to algorytm, który opiera się na stopniowym ulepszaniu początkowego, losowego rozwiązania. W przypadku problemu komiwojażera algorytm stara się skrócić trasę w taki sposób, aby odwiedzić wszystkie punkty. TS działa w sposób iteracyjny – w każdej iteracji obecne rozwiązanie jest modyfikowane poprzez wybór jednego z ruchów zdefiniowanych w sąsiedztwie. Charakterystyczną cechą algorytmu TS jest lista tabu, która przechowuje ruchy wykonane w ostatnich iteracjach. Ruchy te są czasowo zakazane, co zapobiega zapętleniu się algorytmu i ponownemu odwiedzaniu tych samych rozwiązań. Algorytm pozwala również na wykonanie ruchu, który chwilowo pogarsza rozwiązanie. Taki mechanizm umożliwia ucieczkę z lokalnych ekstremów i zwiększa szansę na znalezienie rozwiązania globalnie optymalnego lub bliskiego optymalnemu. Dodatkowo TS może korzystać z kryterium zakończenia działania, które przerywa algorytm, jeśli przez dłuższy czas nie nastąpi poprawa wyniku.
</div>

## Badane parametry

W ramach algorytmu przeszukiwania tabu badane są następujące parametry:

 - **`długość listy tabu`** - liczba wykonanych ruchów, które nie mogą być ponownie wykorzystanie przez określoną liczbę iteracji
 
 - **`liczba iteracji bez poprawy`** - liczba iteracji, po której algorytm kończy działanie, jeśli nie znaleziono lepszego rozwiązania
 
 - **`rodzaj sąsiedztwa`** - metoda generowania nowych rozwiązań na podstawie aktualnego rozwiązania. W badaniu uwzględniono typy:
 
    - `swap` nowe rozwiązanie powstaje poprzez zamianę miejscami dwóch miast w bieżącej trasie
    
    - `insertion` polega na wyborze jednego miasta z danej trasy, usunięciu go z jego pierwotnej pozycji, a następnie wstawieniu go w inne, wybrane miejsce w tej samej trasie
    
    - `2-opt` wiąże się z odwróceniem segmentu trasy między dwoma wybranymi wierzchołkami, co prowadzi do zmiany kolejności miast w tym segmencie
  
    <p style="margin-top: 10px;">
 - **`czas działania`** - limit czasu, jaki posiada algorytm na znalezienie rozwiązania
    </p>

```{r echo=FALSE, include=FALSE}
TS_clasic <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/TS.xlsx", 
    sheet = "Basic")
TS_move_generator <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/TS.xlsx", 
    sheet = "move_generator")
TS_list_length <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/TS.xlsx", 
    sheet = "tabu_list_length")
TS_max_iterations <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/TS.xlsx", 
    sheet = "max_iterations")
TS_max_no_improve <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/TS.xlsx", 
    sheet = "max_no_improve")
TS_time_limit <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/TS.xlsx", 
    sheet = "time_limit")
```

## Klasyczny

Za podstawowe dane przyjmujemy:

* tabu_list_length = 10

* max_iterations = 10000

* max_no_improve = 50

* move_type = `two_opt`

* time_limit = 1000

```{r, echo=FALSE}
TS_clasic_tsp48 <- TS_clasic %>%
  filter(DATASET == "DATA1") %>%
  select(WYNIK) %>%
  as.data.frame()

TS_clasic_tsp76 <- TS_clasic %>%
  filter(DATASET == "DATA2") %>%
  select(WYNIK) %>%
  as.data.frame()

TS_clasic_tsp127 <- TS_clasic %>%
  filter(DATASET == "DATA3") %>%
  select(WYNIK) %>%
  as.data.frame()

TS_clasic_wyniki <- cbind(TS_clasic_tsp48)
TS_clasic_wyniki <- cbind(TS_clasic_wyniki, TS_clasic_tsp76)
TS_clasic_wyniki <- cbind(TS_clasic_wyniki, TS_clasic_tsp127)

colnames(TS_clasic_wyniki) <- c("TSP_48", "TSP_76", "TSP_127")
TS_clasic_wyniki
```

```{r, echo=FALSE}
TS_clasic_stat <- TS_clasic %>%
  group_by(DATASET) %>%
  summarise(
    Mean = mean(WYNIK),
    Min = min(WYNIK),
    Max = max(WYNIK)
  ) %>%
  as.data.frame()              

rownames(TS_clasic_stat) <- c("TSP_48", "TSP_76", "TSP_127")

TS_clasic_stat[,c("Min", "Max", "Mean")]
```

Powyżej w tabelkach możemy zobaczyć uzyskane wyniki dla podstawowych wartości parametrów dla algorytmu przeszukiwania tabu oraz minimalną, maksymalną i średnią wartość. Średnie dla TSP_48 i TSP_76 są zbliżone do tych uzyskanych przez Solver. Natomiast dla TSP_127 wyniki oraz średnia są zdecydowanie wyższe.

```{r, echo=FALSE,warning=FALSE, message=FALSE}
TS_clasic_time <- TS_clasic %>%
  group_by(DATASET) %>%
  select(CZAS) %>%
  summarise(
    Min = min(CZAS),
    Max = max(CZAS),
    Mean = mean(CZAS)
  ) %>% 
  as.data.frame()
  
rownames(TS_clasic_time) <- c("TSP_48", "TSP_76", "TSP_127")

TS_clasic_time[,2:4]
```

Średnie czasy są bardzo niskie, zwłaszcza w porównaniu do Solvera.

## Rodzaje ruchów

Poniżej zbadany został wpływ rodzaju ruchu na długość ścieżki:

```{r, echo=FALSE}
TS_move_generator_tsp48 <- TS_move_generator %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

TS_move_generator_tsp76 <- TS_move_generator %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

TS_move_generator_tsp127 <- TS_move_generator %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(TS_move_generator_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Typ ruchu",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
TS_move_generator_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Pojawiła nam się tutaj również zależność pomiędzy rodzajem ruchów, a medianą i średnią długością ścieżki. Najlepsze wyniki uzyskiwane są dla rodzaju ruchu `2-opt`, a najgorsze dla `swap`. Wyniki dla `2-opt` charakteryzują się małą wariancją (rozkład jest wąski), co wskazuje na niewielkie różnice w długościach ścieżek. 

```{r, echo=FALSE}
ggplot(TS_move_generator_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Typ ruchu",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
TS_move_generator_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_76 mamy podobną sytuację. Wyniki są najlepsze dla `2-opt`, najgorsze dla `swap`. Podobna jest też sytuacja z wariancją dla `2-opt`. Nie ma tam takiej różnorodności jak w pozostałych.

```{r, echo=FALSE}
ggplot(TS_move_generator_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Typ ruchu",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
TS_move_generator_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_127 analogiczna sytuacja. Jednak pomimo różnych rodzjaów ruchów, wyniki nadal są zdecydowanie gorsze.

Na podstawie analizy widać dużą zależność długości ścieżki od rodzju ruchów. W każdym z przypadków, najlepsze wyniki uzyskano dla `2-opt`, a najgorsze dla `swap`. Ponadto rozkłady wyników dla `2-opt` charakteryzują się małą wariancją w odróżnieniu do pozostałych.

## Długość listy tabu

Poniżej zbadany został wpływ długości listy tabu na długość ścieżki:

```{r, echo=FALSE}
TS_list_length_tsp48 <- TS_list_length %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

TS_list_length_tsp76 <- TS_list_length %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

TS_list_length_tsp127 <- TS_list_length %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(TS_list_length_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Długośc listy tabu",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
TS_list_length_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Mediana i średnia długości ścieżki na początku maleje, ale później znowu rośnie. W przypadku TSP_48 liczaba miast jest stosunkowo mała, więc przy zbyt długiej liście tabu algorytm  może zabraniać zbyt wiele rozwiązań. Dlatego w w przypadku długości listy tabu = 15 i 20, średnie i mediana są wyższe niż dla długości listy = 10. Natomiast 5 może być zbyt małą liczbą i algorytm nie zapamiętuje wystarczającej liczby ostatnich ruchów, co oznacza, że łatwo może powrócić do wcześniej odwiedzonych rozwiązań.

```{r, echo=FALSE}
ggplot(TS_list_length_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Długośc listy tabu",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
TS_list_length_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_76 ciężko wyciągnąć jakąś zależność z wykresów. Mediana i średnia się wahają. Nie sprawdzają się tutaj poprzednie wyjaśnienia. Może należałoby sprawdzić więcej wartości tego parametru w tym przypadku.

```{r, echo=FALSE}
ggplot(TS_list_length_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Długośc listy tabu",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
TS_list_length_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Natomiast dla TSP_127 widać dobrze, że wraz ze wzrostem długości listy, maleje śrenia i mediana długości ścieżki. Przy tak dużej liczbie miast (127), mała lista tabu nie spełnia dobrze swojej roli i często algorytm wraca do rozwiązań już odwiedzonych. 

Pojawia się tu pewna zależnośc między długością listy tabu, a długością ścieżki. Jednak duży też zależy od liczby miast w problemie komiwojażera. Od niego powinna być uzależniona długośc listy tabu. Dla TSP_48 można byłby sprawdzić więcej wartości tego parametru, może wtedy ta zależność byłaby tam bardziej widoczna. Natomiast ciekawy przypadek jest dla TSP_76. Ciężko tam stwierdzić, aby jakakolwiek zależność istaniała.

## Liczba iteracji

Poniżej zbadany został wpływ liczby iteracji na długość ścieżki:

```{r, echo=FALSE}
TS_max_iterations_tsp48 <- TS_max_iterations %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

TS_max_iterations_tsp76 <- TS_max_iterations %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

TS_max_iterations_tsp127 <- TS_max_iterations %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(TS_max_iterations_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Liczba iteracji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
TS_max_iterations_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

W przypadku liczby iteracji pojawiła się ciekawa sytuacja. Mediana długości ścieżki rośnie wraz z liczbą iteracji. Średnia natomiast wzrosła w odniesieniu do liczby iteracji = 500. Spodziewalibyśmy się raczej odwrotnej sytuacji Niezależnie od wartości parametru, w każdym przypadku minimalna wartość jest niższa od tej uzyskanej przez Solver (10868). Średnie są natomiast zbliżone.

```{r, echo=FALSE}
ggplot(TS_max_iterations_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Liczba iteracji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
TS_max_iterations_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

W tym przypadku natomiast średnia zmalała i mediana również w odniesieniu do liczby iteracji = 500. Pojawiła się odwrotna sytuacja niż dla TSP_48. Wyniki są zdecydowanie lepsze niż te uzyskane przez Solver (118293.5). Średnia również zdecydowanie zmalała.

```{r, echo=FALSE}
ggplot(TS_max_iterations_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Liczba iteracji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
TS_max_iterations_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Tutaj pojawia się podobna zależnośc co w przypadku TSP_48. Średnia i mediana rosną w porównaniu do tych uzyskanych dla liczby iteracji = 500. Jednak wyniki również w tym przypadku są zdecydowanie lepsze niż te uzyskane przez Solver(140217.6).

Ciężko więc stwierdzić czy jest tu jakaś zależność. W 2/3 przypadki wzrost liczby iteracji powodowaj wzrost średniej i mediana.

## Liczba iteracji bez poprawy

Poniżej zbadany został wpływ liczby iteracji bez poprawy na długość ścieżki:

```{r, echo=FALSE}
TS_max_no_improve_tsp48 <- TS_max_no_improve %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

TS_max_no_improve_tsp76 <- TS_max_no_improve %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

TS_max_no_improve_tsp127 <- TS_max_no_improve %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(TS_max_no_improve_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Liczba iteracji bez poprawy",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
TS_max_no_improve_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Na początku widać, że mediana i średnia długości ścieżki maleją znacząco. Później jednak następuję wzrost tych statystyk. Przy zwiększaniu liczby iteracji bez poprawy, algorytm ma więcej czasu na eksplorację, co pozwala mu unikać lokalnych minimów i znajdować lepsze rozwiązania. Jednak zbyt duże wartości powodują, że algorytm zaczyna eksplorować przestrzeń rozwiązań zbyt długo, nawet w sytuacjach, gdy lepsze rozwiązania już się nie pojawiają, stąd wzrost średniej i mediany.

```{r, echo=FALSE}
ggplot(TS_max_no_improve_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Liczba iteracji bez poprawy",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
TS_max_no_improve_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Sytaucja jest tutaj podobna. Jednak już przy liczbie iteracji bez poprawy = 150 mamy wzrost mediany i średniej. Dla TSP_76 już od tej wartości algorytm może zbyt długo poszukiwać lepszego rozwiązania. Natomiast otrzymane wyniki są bardzo.

```{r, echo=FALSE}
ggplot(TS_max_no_improve_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Liczba iteracji bez poprawy",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
TS_max_no_improve_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Tutaj sytuacja jest cięższa do zdefiniowania. Mediana raz maleje raz rośnie. Natomiast średnia utrzymuje się na podobnym poziomie. Otrzymane wyniki są zdecydowanie lepsze.

Można więc powiedzieć, że trzeba odpowiednio dostosować liczbę iteracji bez poprawy. Zbyt mała liczba może spowodować, że algorytm nie będzie eksplorował dostatecznie głęboko przestrzeni rozwiązań i szybko zatrzyma się na minimach lokalnych. Natomiast zbyt duża liczba iteracji bez poprawy może spowodować, że algorytm przejdzie przez wiele słabszych rozwiązań i poświęci zbyt dużo czasu na mniej obiecujące rozwiązania.

## Limit czasowy

Poniżej zbadany został wpływ liczby iteracji bez poprawy na długość ścieżki:

```{r, echo=FALSE}
TS_time_limit_tsp48 <- TS_time_limit %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

TS_time_limit_tsp76 <- TS_time_limit %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

TS_time_limit_tsp127 <- TS_time_limit %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(TS_time_limit_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Limit czasowy",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
TS_time_limit_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Mediana oraz średnia się wahają. Nie widać tu zależności limitu czasu od długości ścieżki. Wyniki natomiast są zbliżone do tych z Solvera.

```{r, echo=FALSE}
ggplot(TS_time_limit_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Limit czasowy",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
TS_time_limit_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Tutaj podobna sytuacja. Średnia i mediana raz rosną, raz maleją.

```{r, echo=FALSE}
ggplot(TS_time_limit_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Limit czasowy",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
TS_time_limit_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_127 na początku widać duży spadek wartości mediany i średniej. Nie było to w widoczne w poprzenich TSP w takim stopniu. Może to się wiązać z tym, że TSP_127 ma największą liczbę miast, więc limit czasowy = 60s był zbyt mały dla niego.

Nie widać tutaj żadnej zależności długości ścieżki od limitu czasu. Jedynie dla TSP_127 pojawiła się bardziej znacząca różnica w odniesieniu do początkowego limitu.

## Podsumowanie

Najlepszy wyniki dla TSP_48 przy zmianie poszczególnych parametrów:

* Klasyk - 10851.0	

* Rodzaje ruchów - 10941 (rodzaj ruchu - 2-opt)

* Długość listy tabu - 10837 (długość listy tabu - 10)

* Liczba iteracji - 10788	(liczba iteracji - 2500)

* Liczba iteracji bez poprawy - 10827	(liczba iteracji bez poprawy - 150)

* Limit czasu - 10854	(limit czasu - 1000)

Dla TSP_48 przy użyciu algorytmu tabu search udało się uzyskać pare lepszych wyników niż ten uzyskany przez Solver (10868).

Najlepszy wyniki dla TSP_76 przy zmianie poszczególnych parametrów:

* Klasyk - 129754.0	

* Rodzaje ruchów - 128558.9 (rodzaj ruchu - 2-opt)

* Długość listy tabu - 109983.6 (długość listy tabu - 10)

* Liczba iteracji - 110137.5 (liczba iteracji - 1500)

* Liczba iteracji bez poprawy - 109939.4 (liczba iteracji bez poprawy - 150)

* Limit czasu - 110041.2	(limit czasu - 240)

Dla TSP_76 przy użyciu algorytmu tabu search również udało się uzyskać kilka lepszych wyników niż ten uzyskany przez Solver (118293.5)

Najlepszy wyniki dla TSP_127 przy zmianie poszczególnych parametrów:

* Klasyk - 204850.2	

* Rodzaje ruchów - 200281.5 (rodzaj ruchu - 2-opt)

* Długość listy tabu - 121462.2 (długość listy tabu - 20)

* Liczba iteracji - 121398.3 (liczba iteracji - 1000)

* Liczba iteracji bez poprawy - 120791.7	(liczba iteracji bez poprawy - 10)

* Limit czasu - 121926.2	(limit czasu - 1000)

Dla TSP_127 przy użyciu algorytmu tabu search udało się uzyskać lepsze wyniki niż ten uzyskany przez Solver (140217.6)

# Algorytm genetyczny

<div style='text-align: justify'>
**Algorytm genetyczny** (ang. Genetic Algorithm, GA) to technika optymalizacyjna, która przeszukuje przestrzeń możliwych rozwiązań danego problemu, wykorzystując elementy losowe w celu znalezienia najlepszego rozwiązania. Jego działanie naśladuje proces ewolucji biologicznej. Początkowa populacja rozwiązań poddawana jest serii operacji, takich jak krzyżowanie oraz mutacje, co prowadzi do powstania nowej generacji. Proces ten jest powtarzany wielokrotnie, aż do osiągnięcia określonej liczby iteracji lub spełnienia innych warunków stopu. 
</div>

## Badane parametry

W ramach algorytmu genetycznego badane są następujące parametry:

 - **`wielkość populacji`** - liczba osobników w populacji, które będą brane pod uwagę w danej iteracji algorytmu
 
 - **`prawdopodobieństwo mutacji`** - prawdopodobieństwo z jakim nastąpi mutacja genów w osobnikach
 
 - **`prawdopodobieństwo krzyżowania`** - prawdopodobieństwo z jakim nastąpi krzyżowanie osobników w populacji
 
 - **`metoda doboru rodziców`** - sposób wyboru najlepszych osobników do reprodukcji:
 
   - `turniejowy` - losowana jest grupa osobników stanowiąca 10% populacji, a jako rodzic wybierany jest osobnik z najkrótszą trasą
   
   - `rankingowy` - wybór rodzica odbywa się na podstawie rankingu osobników, przy czym zwracana jest tylko jedna ścieżka
   
   <p style="margin-top: 10px;">
 - **`metoda krzyżowania`** - sposób łączenia genów (tras) rodziców w celu stworzenia potomków:
 
   - `order crossover (OX)` - z pierwszego rodzica wybierany jest losowy segment miast, który jest kopiowany do potomka w to samo miejsce, pozostałe miasta są uzupełniane w potomku zgodnie z ich kolejnością wystąpienia w drugim rodzicu
   
   - `partially matched crossover (pmx)` - dziedziczenie części trasy od każdego z rodziców przy zachowaniu oryginalnej kolejności odwiedzonych miast, jednocześnie eliminując duplikaty w nowo powstałym rozwiązaniu 
   </p>
   
   <p style="margin-top: 10px;">
 - **`metoda mutacji`** - metoda generowania nowych rozwiązań na podstawie aktualnego rozwiązania. W badaniu uwzględniono typy:
 
    - `swap` nowe rozwiązanie powstaje poprzez zamianę miejscami dwóch miast w bieżącej trasie
    
    - `insertion` polega na wyborze jednego miasta z danej trasy, usunięciu go z jego pierwotnej pozycji, a następnie wstawieniu go w inne, wybrane miejsce w tej samej trasie
    
    - `inversion` odwrócenie kolejności odwiedzanych miast w wybranym segmencie trasy
    </p>
    
    <p style="margin-top: 10px;">
 - **`liczba pokoleń`** - liczba iteracji algorytmu 
    </p>
    
```{r echo=FALSE, include=FALSE}
GA_klasyk <- read_excel("C:/Users/Justyna/Desktop/GA.xlsx", 
    sheet = "Basic")
GA_population_size <- read_excel("C:/Users/Justyna/Desktop/GA.xlsx", 
    sheet = "population_size")
GA_mutation_rate <- read_excel("C:/Users/Justyna/Desktop/GA.xlsx", 
    sheet = "mutation_rate")
GA_crossover_rate <- read_excel("C:/Users/Justyna/Desktop/GA.xlsx", 
    sheet = "crossover_rate")
GA_generations <- read_excel("C:/Users/Justyna/Desktop/GA.xlsx", 
    sheet = "generations")
GA_selection_method <- read_excel("C:/Users/Justyna/Desktop/GA.xlsx", 
    sheet = "selection_method")
GA_crossover_method <- read_excel("C:/Users/Justyna/Desktop/GA.xlsx", 
    sheet = "crossover_method")
GA_mutation_method <- read_excel("C:/Users/Justyna/Desktop/GA.xlsx", 
    sheet = "mutation_method")
```

## Klasyczny

Za podstawowe dane przyjmujemy:

* population_size = 10 

* generations = 5000

* crossover_rate = 0.6

* mutation_rate = 0.15

* selection_method = `tournament`
    
* crossover_method = `order`
    
* mutation_method = `2-opt`

```{r, echo=FALSE}
GA_klasyk_wyniki_tsp48 <- GA_klasyk %>%
  filter(DATASET == "DATA1") %>%
  select(WYNIK) %>%
  as.data.frame()

GA_klasyk_wyniki_tsp76 <- GA_klasyk %>%
  filter(DATASET == "DATA2") %>%
  select(WYNIK) %>%
  as.data.frame()

GA_klasyk_wyniki_tsp127 <- GA_klasyk %>%
  filter(DATASET == "DATA3") %>%
  select(WYNIK) %>%
  as.data.frame()

GA_klasyk_wyniki <- cbind(GA_klasyk_wyniki_tsp48)
GA_klasyk_wyniki <- cbind(GA_klasyk_wyniki, GA_klasyk_wyniki_tsp76)
GA_klasyk_wyniki <- cbind(GA_klasyk_wyniki, GA_klasyk_wyniki_tsp127)

colnames(GA_klasyk_wyniki) <- c("TSP_48", "TSP_76", "TSP_127")
GA_klasyk_wyniki
```

```{r, echo=FALSE}
GA_klasyk_stat <- GA_klasyk %>%
  group_by(DATASET) %>%
  summarise(
    Mean = mean(WYNIK),
    Min = min(WYNIK),
    Max = max(WYNIK)
  ) %>%
  as.data.frame()              

rownames(GA_klasyk_stat) <- c("TSP_48", "TSP_76", "TSP_127")

GA_klasyk_stat[,c("Min", "Max", "Mean")]
```

W tabelce widzimy statystyki uzyskane dla podstawowych wartości parametrów dla algorytmu genetycznego. Średnie różnią dla TSP_76 i TSP_127 różnią się od tych uzyskanych przez Solver. Dla liczby miast = 76 jest ona niższa. Natomiast dla liczby miast = 127 zdecydowanie wyższa.

**Czas**

```{r, echo=FALSE, warning=FALSE, message=FALSE}
GA_clasic_time <- GA_klasyk %>%
  group_by(DATASET) %>%
  select(CZAS) %>%
  summarise(
    Min = min(CZAS),
    Max = max(CZAS),
    Mean = mean(CZAS)
  ) %>% 
  as.data.frame()
  
rownames(GA_clasic_time) <- c("TSP_48", "TSP_76", "TSP_127")

GA_clasic_time[,2:4]
```

Średnie czasy dla każdego z przypadków są bardzo niskie.

## Wielkość populacji

Poniżej zbadany został wpływ wielkości populacji na długość ścieżki:

```{r, echo=FALSE}
GA_population_size_tsp48 <- GA_population_size %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

GA_population_size_tsp76 <- GA_population_size %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

GA_population_size_tsp127 <- GA_population_size %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(GA_population_size_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Wielkość populacji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
GA_population_size_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Średnia i mediana dla wielkości populacji = 5 są zdecydowanie wyższe niż w pozostałych przypadkach. Dla innych parametrów utrzymują się na podobnym poziomie.

```{r, echo=FALSE}
ggplot(GA_population_size_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Wielkość populacji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
GA_population_size_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_76 dla parametru = 5 średnia i mediana są również największe w porównaniu do pozosałych wyników. Natępnie widać, że wraz ze wzrostem liczby populacji, maleje średnia i mediana.

```{r, echo=FALSE}
ggplot(GA_population_size_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Wielkość populacji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
GA_population_size_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Tutaj pojawia się analogiczna sytaucja jak dla TSP_76. Gdy zwiększyła się liczba miast, bardziej widoczna stała się zależność, że wraz ze wzrostem liczby populacji, maleje średnia i mediana długości ścieżki.

Liczba populacji = 5 w każdym z przypadków dała najwyższe długości ścieżki. Natomiast wraz ze wzrostem parametru, maleje długość ścieżki. Może tak być dlatego, że większa populacja (wieksza liczba osobników w każdej generacji algorytmu) zwiększa różnorodność rozwiązań, co zwiększa szansę na znalezienie lepszego rozwiązania i pozwala uniknąć utknięcia w minimach lokalnych.

## Prawdopodobieństwo mutacji

Poniżej zbadany został wpływ prawdopodobieństwa mutacji na długość ścieżki:

```{r, echo=FALSE}
GA_mutation_rate_tsp48 <- GA_mutation_rate %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

GA_mutation_rate_tsp76 <- GA_mutation_rate %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

GA_mutation_rate_tsp127 <- GA_mutation_rate %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(GA_mutation_rate_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Prawdopodobieństwo mutacji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
GA_mutation_rate_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Wraz ze wzrostem prawdopodobieństwa mutacji, maleje średnia i mediana długości ścieżki. 

```{r, echo=FALSE}
ggplot(GA_mutation_rate_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Prawdopodobieństwo mutacji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
GA_mutation_rate_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_76 jest identyczna sytuacja, a nawet bardziej widoczna.

```{r, echo=FALSE}
ggplot(GA_mutation_rate_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Prawdopodobieństwo mutacji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
GA_mutation_rate_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Analogicznie lda TSP_127. Chociaż średnia w tym przypadku nawet dla parametru = 0.2 jest wyższa niż ta uzyskana w Solverza.

Widać w każdym z przypadków, bardzo dobrze, że wraz ze wzrostem prawdopodobieństwa mutacji, maleje długość ścieżki. Mutowanie pozwala na eksplorowanie większej liczby rozwiązań. Niskie wartości parametru powodują, że osobniki w populacji są do siebie dość zbliżone, dlatego długości ścieżki są wtedy większe.

## Prawdopodobieństwo krzyżowania

Poniżej zbadany został wpływ prawdopodobieństwa krzyżowania na długość ścieżki:

```{r, echo=FALSE}
GA_crossover_rate_tsp48 <- GA_crossover_rate %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

GA_crossover_rate_tsp76 <- GA_crossover_rate %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

GA_crossover_rate_tsp127 <- GA_crossover_rate %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(GA_crossover_rate_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Prawdopodobieństwo krzyżowania",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
GA_crossover_rate_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Widzimy na początku spadek wartości mediany i średniej. Natomiast później zaczynają delikatnie rosnąć.

```{r, echo=FALSE}
ggplot(GA_crossover_rate_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Prawdopodobieństwo krzyżowania",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
GA_crossover_rate_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_76 jest już trochę inna sytuacja. Średnia i mediana od początku delikatnie rosną, a później wahają się wokół zbliżonych wartości.

```{r, echo=FALSE}
ggplot(GA_crossover_rate_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Prawdopodobieństwo krzyżowania",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
GA_crossover_rate_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Tutja jest podobona sytaucja jak dla TSP_76.

Ciężko zauważyć tutaj jakąś istotną zależność. Średnie i mediany nie różnią się znacząco.

## Liczba pokoleń

Poniżej zbadany został wpływ liczby pokoleń na długość ścieżki:

```{r, echo=FALSE}
GA_generations_tsp48 <- GA_generations %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

GA_generations_tsp76 <- GA_generations %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

GA_generations_tsp127 <- GA_generations %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(GA_generations_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Liczba pokoleń",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
GA_generations_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Wraz ze wzrostem liczby pokoleń następuje spadek wartości mediany, jednak na końcu ona wzrasta. Średnia natomiast raz rośnie raz maleje. 

```{r, echo=FALSE}
ggplot(GA_generations_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Liczba pokoleń",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
GA_generations_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_76 widać, że wraz ze wzrostem liczby pokoleń, maleje zarówno średnia jak i mediana. 

```{r, echo=FALSE}
ggplot(GA_generations_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Liczba pokoleń",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
GA_generations_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Tutaj pojawia się analogiczna sytuacja, jak dla TSP_76.

Wraz ze wzrostem liczby pokoleń (inaczej liczby iteracji algorytmu), maleje długość ścieżki. Jest to dość logiczna zależność. Większa liczba iteracji zwiększa szanse na dokładne przeszukanie przestrzeni. 

## Metoda doboru rodziców

Poniżej zbadany został wpływ metoda doboru rodziców na długość ścieżki:

```{r, echo=FALSE}
GA_selection_method_tsp48 <- GA_selection_method %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

GA_selection_method_tsp76 <- GA_selection_method %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

GA_selection_method_tsp127 <- GA_selection_method %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(GA_selection_method_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Metoda doboru rodziców",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
GA_selection_method_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dobieranie rodziców metodą ruletki zdecydowanie sie nie sprawdza. Wyniki nawet nie są zbliżone do tych osiągniętych przy metodzie ruletki.

```{r, echo=FALSE}
ggplot(GA_selection_method_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Metoda doboru rodziców",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
GA_selection_method_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Tutaj sytuacja analogiczna. Różnica jest diametralna, pomiędzy wynikami.

```{r, echo=FALSE}
ggplot(GA_selection_method_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Metoda doboru rodziców",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
GA_selection_method_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_127 analogicznie.

Wyniki są definitywnie lepsze w przypadku metody doboru rodziców w sposób truniejowy. W ruletce wybór jest mocno losowy, co może prowadzić do selekcji słabszych osobników w wielu iteracjach. Natomiast metoda turniejowa z spośród losowo wybranych osobników, zawsze wybiera tego o najniższym koszcie, dlatego może działać lepiej.

## Metoda krzyżowania

Poniżej zbadany został wpływ metoda krzyżowania na długość ścieżki:

```{r, echo=FALSE}
GA_crossover_method_tsp48 <- GA_crossover_method %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

GA_crossover_method_tsp76 <- GA_crossover_method %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

GA_crossover_method_tsp127 <- GA_crossover_method %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(GA_crossover_method_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Metoda krzyżowania",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
GA_crossover_method_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Średnia i mediana śa bardzo zbliżone do siebie. Żadna z metod się nie wyróżnia.

```{r, echo=FALSE}
ggplot(GA_crossover_method_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Metoda krzyżowania",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
GA_crossover_method_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_76 mediana w przypadku metody `pmx` jest zdecydowanie wyższa. Średnie natomiast są zbliżone. 

```{r, echo=FALSE}
ggplot(GA_crossover_method_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Metoda krzyżowania",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
GA_crossover_method_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_127 zarówno mediana i średnia są do siebie zbliżone.

Nie widać więc tutaj żadnej zależności.

## Metoda mutacji

Poniżej zbadany został wpływ metoda mutacji na długość ścieżki:

```{r, echo=FALSE}
GA_mutation_method_tsp48 <- GA_mutation_method %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

GA_mutation_method_tsp76 <- GA_mutation_method %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

GA_mutation_method_tsp127 <- GA_mutation_method %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(GA_mutation_method_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Metoda mutacji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
GA_mutation_method_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_48 najlepiej sprawdziła się metoda mutacji `inversion`. Natomiast najgorzej wypadła metoda `swap`. Metoda `insertion` nie ma dużo gorszych wyników.

```{r, echo=FALSE}
ggplot(GA_mutation_method_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Metoda mutacji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
GA_mutation_method_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Tutaj pojawia się podobna sytuacja. Metoda `inversion` daje najlepsze wyniki. Jednak jest już większa różnica pomiędzy metodami.

```{r, echo=FALSE}
ggplot(GA_mutation_method_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Metoda mutacji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
GA_mutation_method_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_127 analogiczna sytuacja.

Naefektywniejsza jest metoda `inversion` we wszystkich przypadkach. Najgorzej natomiast wypada `swap`.

## Podsumowanie

Najlepszy wyniki dla TSP_48 przy zmianie poszczególnych parametrów:

* Klasyk - 	11048.0

* Wielkość populacji - 10795 (wielkość populacji - 15)

* Prawdopodobieństwo mutacji - 11055	(prawd. mutacja - 0.2)

* Prawdopodobieństwo krzyżowania -  10920 (prawd. krzyżowanie - 0.9)

* Liczba pokoleń -  10975 (liczba pokoleń - 10 tys.)

* Metoda doboru rodziców - 11173	(metoda - tournament)

* Metoda krzyżowania - 10803	(metoda - order)

* Metoda mutacji - 10936	(metoda - inversion)

Dla TSP_48 przy użyciu algorytmu mrówkowego udało się uzyskać lepszy wynik niż ten uzyskany przez Solver (10868).

Najlepszy wyniki dla TSP_76 przy zmianie poszczególnych parametrów:

* Klasyk - 	116714.4

* Wielkość populacji - 112600.5	 (wielkość populacji - 20)

* Prawdopodobieństwo mutacji - 115561.1	(prawd. mutacja - 0.2)

* Prawdopodobieństwo krzyżowania - 118452.6	(prawd. krzyżowanie - 0.8)

* Liczba pokoleń - 112672.9 (liczba pokoleń - 15 tys.)

* Metoda doboru rodziców - 121744.9	(metoda - tournament)

* Metoda krzyżowania - 121250.0		(metoda - pmx)

* Metoda mutacji - 121265.7	(metoda - inversion)

Dla TSP_76 przy użyciu algorytmu mrówkowego udało się uzyskać lika lepszych wyników niż ten uzyskany przez Solver (118293.5)

Najlepszy wyniki dla TSP_127 przy zmianie poszczególnych parametrów:

* Klasyk - 	165047.0

* Wielkość populacji - 141116.7 (wielkość populacji - 20)

* Prawdopodobieństwo mutacji - 162368.2	(prawd. mutacja - 0.2)

* Prawdopodobieństwo krzyżowania - 152547.3	(prawd. krzyżowanie - 0.7)

* Liczba pokoleń - 133161.4 (liczba pokoleń - 15.tys)

* Metoda doboru rodziców - 157986.9	(metoda - tournament)

* Metoda krzyżowania - 160299.3	(metoda - order)

* Metoda mutacji - 169240.5	(metoda - inversion)

Dla TSP_127 przy użyciu algorytmu mrówkowego udało się uzyskać lepszy wynik niż ten uzyskany przez Solver (140217.6)

# Algorytm mrówkowy

<div style='text-align: justify'>
 Algorytm mrówkowy został stworzony na podstawie obserwacji życia mrówek podczas szukania optymalnej drogi między mrowiskiem a źródłem pożywienia. Mrówki w środowisku naturalnym poruszają się losowo, ale zostawiają na swojej drodze feromony, które pomagają innym mrówkom znaleźć najkrótszą ścieżkę. Z czasem feromony parują (ich wpływ maleje), co pozwala wyeliminować nieoptymalne ścieżki. Algorytm ten dobrze sprawdza się w rozwiązywaniu problemu komiwojażera.
</div>

Zasada działania algorytmu do rozwiązania problemu komiwojażera wygląda następująco:

1. Połączenie między miastami inicjowane są niewielką ilością feromonu.

2. Każda mrówka umieszczana jest losowo w wybranym mieście, z którego przemieszcza się do kolejnego z prawdopodobieństwem P, będącym funkcją odległości do celu oraz wielkości śladu feromonowego pozostawionego na krawędzi łączącej je z tym miastem.

3. Mrówka poruszając się z miasta i do miasta j pozostawia za sobą ślad feromonowy odwrotnie proporcjonalny do długości trasy, którą przebyła .

4. Sztuczna mrówka wyposażona jest w pamięć w celu zapamiętania, które miasto już odwiedziła, aby uwzględnić je tylko jeden raz w swojej trasie (pamięć jest czyszczona przy rozpoczęciu każdego kolejnego cyklu przechodzenia).

5. Dla odwzorowania parowania feromonu występującego w naturze, w algorytmie feromon jest pomniejszany o określoną wartość po każdej iteracji, tak aby uniknąć zjawiska przedwczesnej zbieżności algorytmu.

## Parametry

* num_ants - liczba mrówek, która bierze udział w szukaniu optymalnej trasy. Jest ona zależna od liczby miast i wybierana z przedziału (0.5 * liczba miast, 2 * liczba miast)

* num_iterations - liczba iteracji

* alpha - parametr sterujący ważnością intensywności śladu feromonowego

* beta - parametr sterujący ważnością widoczności następnego
miasta

* rho - prędkość odparowywania feromonu

## Klasyczne 

Za podstawowe wartości parametrów przyjmujemy:

* num_ants = 10

* num_iterations = 100

* alpha = 1

* beta = 2

* rho = 0.5

```{r, echo=FALSE, include=FALSE}
klasyk_wyniki <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/ACO.xlsx", 
    sheet = "Klasyk_wyniki")
num_ants <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/ACO.xlsx", 
    sheet = "num_ants")
max_it <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/ACO.xlsx", 
    sheet = "max_it")
alpha <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/ACO.xlsx", 
    sheet = "alpha")
beta <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/ACO.xlsx", 
    sheet = "beta")
rho <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/ACO.xlsx", 
    sheet = "rho")
```

```{r, echo=FALSE}
klasyk_mrowki_tsp48 <- klasyk_wyniki %>%
  filter(DATASET == "DATA1") %>%
  select(WYNIK) %>%
  as.data.frame()

klasyk_mrowki_tsp76 <- klasyk_wyniki %>%
  filter(DATASET == "DATA2") %>%
  select(WYNIK) %>%
  as.data.frame()

klasyk_mrowki_tsp127 <- klasyk_wyniki %>%
  filter(DATASET == "DATA3") %>%
  select(WYNIK) %>%
  as.data.frame()

klasyk <- cbind(klasyk_mrowki_tsp48)
klasyk <- cbind(klasyk, klasyk_mrowki_tsp76)
klasyk <- cbind(klasyk, klasyk_mrowki_tsp127)

colnames(klasyk) <- c("TSP_48", "TSP_76", "TSP_127")
klasyk
```

```{r, echo=FALSE}
klasyk_stat <- klasyk_wyniki %>%
  group_by(DATASET) %>%
  summarise(
    Mean = mean(WYNIK),
    Min = min(WYNIK),
    Max = max(WYNIK)
  ) %>%
  as.data.frame()              

rownames(klasyk_stat) <- c("TSP_48", "TSP_76", "TSP_127")

klasyk_stat[,c("Min", "Max", "Mean")]
```

W tabelce widzimy statystyki uzyskane dla podstawowych wartości parametrów dla algorytmu mrówkowego. Dla TSP_48 i TSP_76 wartości minimalne są wyższe niż uzyskane przez Solver. Jedynie dla TSP_127 otrzymany wynik jest lepszy. Natomiast średnie są dość podobne.

**Czas**

```{r, echo=FALSE, warning=FALSE, message=FALSE}
ACO_clasic_time <- klasyk_wyniki %>%
  group_by(DATASET) %>%
  select(CZAS) %>%
  summarise(
    Min = min(CZAS),
    Max = max(CZAS),
    Mean = mean(CZAS)
  ) %>% 
  as.data.frame()
  
rownames(ACO_clasic_time) <- c("TSP_48", "TSP_76", "TSP_127")

ACO_clasic_time[,2:4]
```

Średnie czasy trwania agorytmu są dość niskie. Jednak zwiększają się w zależności od liczby miast.

## Liczba mrówek

Poniżej zbadany został wpływ liczby mrówek na długość ścieżki:

```{r, echo=FALSE}
num_ants_mrowki_tsp48 <- num_ants %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

num_ants_mrowki_tsp76 <- num_ants %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

num_ants_mrowki_tsp127 <- num_ants %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(num_ants_mrowki_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Liczba mrówek",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
num_ants_mrowki_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_48 możemy zobaczyć zobaczyć z wykresów pudełkowcyh, że wraz ze wzrostem liczby mrówek, która bierze udział w poszukiwaniu optymalnej trasy, mediana długości ścieżki zdecydowanie się obniża. Średnia również widocznie maleje. Najniższa jest dla liczby mrówek równej 84. 

```{r, echo=FALSE}
ggplot(num_ants_mrowki_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Liczba mrówek",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
num_ants_mrowki_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_76 pojawia nam się podobna zależność. Mediana długości ścieżki widocznie się obniża i największe różnice widać na początku. Później te różnice nie są już takie znaczące. Uzyskane średnie dla wszystkich wartości parametrów są niższe niż średnia z Solvera (139999,45).

```{r, echo=FALSE}
ggplot(num_ants_mrowki_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Liczba mrówek",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
num_ants_mrowki_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_127 nie możemy już zobaczyć, tej zależności, że mediana i średnia długości ścieżki maleje wraz ze wzrostem liczby mrówek. Widzimy tutaj, że raz rośnie raz maleje. Średnia długość ścieżki co prawda zmalała od wartości parametru 123, jednak później wraz ze wzrostem jego wartości waha się i nie zmniejsza się znacząco. 

W 2/3 przypadki wskazały, że wraz ze wzrostem liczby mrówek mediana i średnia długości ścieżki maleje. Warto też dodać, że średnie wyniki są lepsze w każdym z przypadków niż te otrzymane dla klasycznych wyników, gdzie liczba mrówek wynosiła 10.

## Liczba iteracji

Poniżej został zbadany wpływ liczby iteracji na długość ścieżki:

```{r, echo=FALSE}
max_it_mrowki_tsp48 <- max_it %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

max_it_mrowki_tsp76 <- max_it %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

max_it_mrowki_tsp127 <- max_it %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(max_it_mrowki_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Liczba iteracji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
max_it_mrowki_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

W przypadku zmian liczby iteracji, nie widać tutaj żadnej zależności. Mediana długości ścieżki raz rośnie raz maleje. Jedyny duży spadek widać na początku. Dla parametrów powyżej wartości 100, mediany już są niższe i średnia również. Poza tym liczba iteracji nie wpływa znacząco na wyniki. 

```{r, echo=FALSE}
ggplot(max_it_mrowki_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Liczba iteracji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
max_it_mrowki_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_76 pojawia się już bardziej widoczna zależność. Mediana i średnia długości ścieżki maleje wraz z liczbą iteracji. Jednak nie w bardzo znaczącym stopniu. Różnice są niewielkie. Pojawia się nam też jeden wyjątek od tej zależności dla liczby iteracji równej 150, gdzie mediana i średnia znacząco spadły. Otrzymane średnie sa niższe niż te otrzymane przez Solver.

```{r, echo=FALSE}
ggplot(max_it_mrowki_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Liczba iteracji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
max_it_mrowki_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_127 spadek mediany i średniej wraz z wzrostem iteracji jest już bardziej widoczny. Jednak pojawiają się też pewne wahania. W odróżnieniu od poprzednich TSP, widać tutaj, że wraz z wzrostem iteracji maleje również minimalna wartość.

Wpływ liczby iteracji wydaje się być częsciowo uzależniony od liczby miast. Gdy wynosiła ona 48 nie widać było zależności. Wraz z zwiększeniem liczby miast stawała się ona bardziej wyraźna. Jednak pojawiały się wtedy pewne wahania.

## Alpha

Poniżej został zbadany wpływ alphy na długość ścieżki:

```{r, echo=FALSE}
alpha_mrowki_tsp48 <- alpha %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

alpha_mrowki_tsp76 <- alpha %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

alpha_mrowki_tsp127 <- alpha %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```


```{r, echo=FALSE}
ggplot(alpha_mrowki_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Alpha",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
alpha_mrowki_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla wartości alpha równej 0 widać znaczną różnicę w medianie i średniej długości ścieżki w porównaniu do pozostałych wartości. Wynika to z faktu, że alpha odpowiada za wpływ intensywności śladu feromonowego na wybory mrówek. Gdy alpha wynosi 0, ślad feromonowy nie ma żadnego wpływu na ich decyzje. W rezultacie, pomimo istnienia informacji o jakości trasy (beta = 2), brak znaczenia intensywności feromonów sprawia, że mrówki nie są w stanie z niej skorzystać.

W przypadku alpha = 1, wyniki są najniższe. Jest to zapewne z wiązane z tym, że stosunek intensywności do widoczności feromonów jest najlepszy. Natomiast wraz ze wzrostem alpha, długość ścieżki rośnie, ponieważ gdy wartość alpha jest za duża w porównaniu do parametru beta, populacja mrówek traci różnorodność. Różnica mediany i średniej między alpha 3 i 4 jest znikoma. Różnica alphy w stosunku do bety jest na tyle wysoka, że zwiększanie alphy nie wpływa na poprawę, badź pogorszenie długości ścieżki.

```{r, echo=FALSE}
ggplot(alpha_mrowki_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Alpha",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
alpha_mrowki_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Tutaj sytuacja jest praktycznie identyczna. Dla alpha = 0 wyniki są najgorsze. Natomiast wraz ze wzrostem parametru (alpha > beta) wyniki się pogarszają do momentu gdzie nie ma już znaczącej różnicy w wynikach.

```{r, echo=FALSE}
ggplot(alpha_mrowki_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Alpha",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
alpha_mrowki_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_127 analogiczna sytuacja.

Wartość parametru alpha istotnie wpływa na długość ścieżki, a tak naprawdę to jego różnica w stosunku do bety. Gdy jest ona odpowiednia, wyniki są najlepsze (średnia i mediana długości ścieżki sa najniższe). W każdym z przypadku najlepsze wyniki uzyskano dla alpha = 1 (beta = 2). Natomiast wyniki nie są lepsze od tych uzsykanych przez Solver. Średnie są porównywalne bądź gorsze.

## Beta

Poniżej został zbadany wpływ bety na długość ścieżki:

```{r, echo=FALSE}
beta_mrowki_tsp48 <- beta %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

beta_mrowki_tsp76 <- beta %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

beta_mrowki_tsp127 <- beta %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(beta_mrowki_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Beta",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
beta_mrowki_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Największa różnica w wynikach (długościach ścieżek) jest widoczna pomiędzy wartościami beta = 1 i beta = 2. Powodem tego jest fakt, że przy beta = 1 i alpha = 1 wpływ obu parametrów – feromonów (alpha) i heurystyki (beta) – jest równoważny. W takiej sytuacji różnica pomiędzy wpływem tych dwóch czynników jest zerowa, co prowadzi do najgorszych wyników. W przypadku bardziej zróżnicowanych wartości alpha i beta (np. beta = 2), jedna z tych strategii ma większy wpływ, co pozwala mrówkom na bardziej skoncentrowane działania i prowadzi do lepszych wyników. Natomiast gdy wartość bety wzrasta, tylko na początku widać delikatną poprawę w wynikach. Później median i średnia długości ścieżki już są bardzo podobne. Wyniki się nie poprawiają.

```{r, echo=FALSE}
ggplot(beta_mrowki_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Beta",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
beta_mrowki_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Tutaj mamy analogiczną sytuację do poprzedniej. Dla bety = 0 wyniki są najgorsze. Następnie już tylko nieznacznie się wahają. 

```{r, echo=FALSE}
ggplot(beta_mrowki_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Beta",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
beta_mrowki_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_127 wzrost wartości paramaetru powoduje poprawę w wynikach. Średnia i mediana długości ścieżki maleją, aż do momentu gdzie już nie uzyskujemy poprawy i wyniki się tylko nieznacznie wahają wokół podobnej wartości. W tym przypadku wzrost wartości bety spowodował największą poprawę.

Współczynnik bety znacząco wpływa na długość ścieżki. Jednak tak jak było wspomniane przy parametrze alpha, największe znaczenie ma różnica między tymi dwoma parametrami.

## Rho

Poniżej został zbadany wpływ rho na długość ścieżki:

```{r, echo=FALSE}
rho_mrowki_tsp48 <- rho %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

rho_mrowki_tsp76 <- rho %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

rho_mrowki_tsp127 <- rho %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(rho_mrowki_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Rho",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
rho_mrowki_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Wyniki średniej i mediany długości ścieżki wahają się wokół podobnych wartości niezależnie od wartości rho. Jedynie znacząca różnica jest dla rho = 0.9, Średnia i mediana są zdecydowanie wyższe. Uzyskane średnie są zdecydowanie wyższe niż te otrzyamne przez Solver.

```{r, echo=FALSE}
ggplot(rho_mrowki_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Rho",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
rho_mrowki_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_76 widzimy natomiast, że różnice w średniej i medianie długości ścieżki są zdecydowanie największe w przypadku skrajnych wartości rho. Bardzo niskie wartości tego parametru oznaczają długotrwałe utrzymywanie się feromonów (bardzo wolne odparowywanie) co prowadzi do nadmiernej eksploatacji jednej trasy, co ogranicza zdolność algorytmu do eksploracji nowych, potencjalnie lepszych tras. Natomiast zbyt wysokie wartościpowodują bardzo szybkie odparowywanie feromonów co sprawia, że ślady na trasach szybko zanikają. W tej sytuacji algorytm prawie w ogóle nie korzysta z informacji zgromadzonych przez inne mrówki, ponieważ ślady feromonowe znikają zanim inne mrówki zdążą je wykorzystać. W związku z tym dla wartości rho, które oscylują wokół 0.5 wyniki są lepsze, ale jednocześnie zbliżone do siebie.

```{r, echo=FALSE}
ggplot(rho_mrowki_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Rho",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
rho_mrowki_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_127 jest podobna sytuacja ze skrajnymi wartościami. Jednak lepsze są wyniki dla wartości rho trochę niższych niż.

Najbardziej optymalne wyniki są uzyskiwane gdy rho przyjmuję wartości bliższe 0.5 niż skrajne (0.1 czy 0.9). Jednak wyniki nie są lepsze niż te uzyskane przez Solver. Jedynie w przypadku TSP_127 udało się otrzymać krótsze długości ścieżki.

## Podsumowanie

Najlepszy wyniki dla TSP_48 przy zmianie poszczególnych parametrów:

* Klasyk - 11540.0	

* Liczba mrówek - 11181 (liczba mrówek - 44)

* Liczba iteracji - 11128	(liczba iteracji - 400)

* Alpha - 11414	(alpha - 1)

* Beta - 11313 (beta - 6)

* Rho - 11246	(rho - 0.7)

Dla TSP_48 przy użyciu algorytmu mrówkowego nie udało się uzyskać lepszego wyniku niż ten uzyskany przez Solver (10868)

Najlepszy wyniki dla TSP_76 przy zmianie poszczególnych parametrów:

* Klasyk - 124560.0		

* Liczba mrówek - 117472.3 (liczba mrówek - 78)

* Liczba iteracji - 117711.1	(liczba iteracji - 150)

* Alpha - 125278.5	(alpha - 1)

* Beta - 117716.2 (beta - 4)

* Rho - 122202.6	(rho - 0.2)

Dla TSP_76 przy użyciu algorytmu mrówkowego udało się uzyskać dwa lepsze wyniki niż ten uzyskany przez Solver (118293.5)

Najlepszy wyniki dla TSP_127 przy zmianie poszczególnych parametrów:

* Klasyk - 134426.3			

* Liczba mrówek - 123471.0 (liczba mrówek - 203)

* Liczba iteracji - 128085.5	(liczba iteracji - 450)

* Alpha - 136597.7	(alpha - 1)

* Beta - 125936.3 (beta - 7)

* Rho - 131834.5	(rho - 0.5)

Dla TSP_127 przy użyciu algorytmu mrówkowego  udało się uzyskać lepsze wyniku niż ten uzyskany przez Solver (140217.6)

