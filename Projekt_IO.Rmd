---
title: "Projekt Inteligencja Obliczeniowa"
author: "Justyna Sarkowicz, Olga Sieradzan, Weronika Duda, Amelia Madej, Aleksandra Węgrzyn"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: 
      collapsed: true
      smooth_scroll: true
    toc_font: "Arial"
    df_print: paged
---

<style>
  img {
    width: 100%;
    height: auto;
  }
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo=FALSE, include=FALSE, message=FALSE, warning=FALSE}
library(readxl)
library(ggplot2)
library(gridExtra)
library(psych)
library(patchwork)
library(dplyr)
library(tidyr)
```

# Wprowadzenie

<div style='text-align: justify'>
**Problem komiwojażera** (ang. Travelling Salesman Problem, TSP) to jedno z najbardziej znanych oraz intensywnie badanych zagadnień w dziedzinie optymalizacji kombinatorycznej oraz teorii grafów. W swojej klasycznej formie problem ten polega na znalezieniu najkrótszej możliwej trasy, która odwiedza dokładnie raz każdy z zadanych punktów i powraca do punktu początkowego. TSP znajduje zastosowanie w wielu dziedzinach, takich jak logistyka, planowanie tras, produkcja czy genetyka.

TSP jest problemem należącym do klasy NP-trudnych, co oznacza, że wraz ze wzrostem liczby punktów (miast) liczba możliwych tras rośnie w sposób wykładniczy, a dokładne rozwiązanie staje się coraz trudniejsze do obliczenia w rozsądnym czasie. Z tego powodu opracowanie efektywnych algorytmów heurystycznych i metaheurystycznych, które pozwalają na znalezienie bliskich optymalnym rozwiązań w akceptowalnym czasie.

Celem naszego projektu jest implementacja sześciu różnych algorytmów, które rozwiązują problem komiwojażera.
</div>

# Solver

<div style='text-align: justify'>
Wyniki uzyskane za pomocą zaimplementowanych algorytmów zostaną porównane z tymi uzyskanymi w Solverze. Będzie to nasz benchmark.
</div>

```{r, echo=FALSE, include=FALSE}
solver <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/Solver.xlsx")
#solver <- read_excel("C:/Users/user/Downloads/Solver.xlsx")
```

```{r, echo=FALSE}
solver[,c(2,4,6)]
```

<div style='text-align: justify'>
W przypadku danych TSP_48 czasy są tutaj dość zbliżone. Najniższy z nich to 92.625 s. Natomiast dla TSP_76 mamy dwie wartości znacząco odstające od pozostałych. Dla TSP_127 czasy są zdecydowanie najdłuższe w stosunku do pozostałych. Nie ma tam tak rozbieżnych wyników jak dla TSP_76. 
</div>

## Statystyki

W statystykach poniżej przedstawiono najkrótszą oraz najdłuższą długość ścieżki uzyskaną przez Solver. Mamy również wyciągniętą średnią ze wszystkich wyników.

```{r, echo=FALSE}
sol_tsp48 <- describe(solver$TSP_48)
sol_tsp76 <- describe(solver$TSP_76)
sol_tsp127 <- describe(solver$TSP_127)
sol <- rbind(sol_tsp48)
sol <- rbind(sol, sol_tsp76)
sol <- rbind(sol, sol_tsp127)
sol <- sol[ ,c("min", "max", "mean")]
rownames(sol) <- c("TSP_48", "TSP_76", "TSP_127")
sol
```

Będzie to nasz benchmark, do którego będziemy odnosić wyniki uzyskane przez pozostałe algorytmy.

# Algorytmu Najbliższego Sąsiada (NN)

<div style='text-align: justify'>
**Algorytm najbliższego sąsiada** (ang. nearest neighbour algorithm, NN) jest prostym algorytmem służącym do rozwiązania prolemu komiwojażera. Jego celem jest znalezienie najkrótszej trasy, która przechodzi przez wszystkie miasta. Proces rozpoczyna się od wybranego miasta, a następnie w każdym kroku wybierane jest najbliższe miasto, które jeszcze nie zostało odwiedzone, do którego algorytm przechodzi. Po odwiedzeniu wszystkich miast algorytm kończy działanie i zwraca uzyskaną trasę.
</div>

## Badane parametry

W ramach algorytmu nalbliższego sąsiada badaniu poddano wpływ różnych wartości parametru `miasto startowe`.

<br>
```{r, echo=FALSE, include=FALSE}
 NN_tsp48 <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/NN.xlsx", 
     sheet = "TSP_48")
 NN_tsp76 <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/NN.xlsx", 
     sheet = "TSP_76")
 NN_tsp127 <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/NN.xlsx", 
     sheet = "TSP_127")

# NN_tsp48 <- read_excel("C:/Users/user/Downloads/NN.xlsx", 
#     sheet = "TSP_48")
# NN_tsp76 <- read_excel("C:/Users/user/Downloads/NN.xlsx", 
#     sheet = "TSP_76")
# NN_tsp127 <- read_excel("C:/Users/user/Downloads/NN.xlsx", 
#     sheet = "TSP_127")
```

```{r, echo=FALSE}
w_tsp48 <- ggplot(NN_tsp48, aes(x = Punkt, y = Wynik)) +
  geom_point(size = 2, position = position_jitter(width = 0.2), colour = "blue") +
  labs(
    title = "TSP_48",
    x = "Punkt początkowy",
    y = "Długość ścieżki"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 10, hjust = 0.5))

w_tsp76 <- ggplot(NN_tsp76, aes(x = Punkt, y = Wynik)) +
  geom_point(size = 2, position = position_jitter(width = 0.2), colour = "blue") +
  labs(
    title = "TSP_76",
    x = "Punkt początkowy",
    y = "Długość ścieżki"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 10, hjust = 0.5))

w_tsp127 <- ggplot(NN_tsp127, aes(x = Punkt, y = Wynik)) +
  geom_point(size = 2, position = position_jitter(width = 0.2), colour = "blue") +
  labs(
    title = "TSP_127",
    x = "Punkt początkowy",
    y = "Długość ścieżki"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 10, hjust = 0.5))

(w_tsp48 + w_tsp76 + w_tsp127 + guide_area()) +
  plot_layout(guides = "collect") +  
  plot_annotation(title = "Długość ścieżki w zależności od punktu startowego",
                  theme = theme(
      plot.title = element_text(size = 14, face = "bold", hjust = 0.5)))
```

Na wykresach widzimy długość trasy w zależności od punktu startowego. Punkt startowy to miasto, z którego zaczynamy szukać najkrótszej trasy. Z wykresów nie da się wiele wyciągnąć, nie ma tutaj żadnej zależności. Widzimy jednak, że wybór punktu początkowego, z którego zaczyna algorytm ma znaczenie.

```{r echo=FALSE, include=FALSE}
stat_NN_tsp48 <- describe(NN_tsp48$Wynik)
stat_NN_tsp76 <- describe(NN_tsp76$Wynik)
stat_NN_tsp127 <- describe(NN_tsp127$Wynik)
stat_NN <- rbind(stat_NN_tsp48)
stat_NN <- rbind(stat_NN, stat_NN_tsp76)
stat_NN <- rbind(stat_NN, stat_NN_tsp127)
stat_NN <- stat_NN[ ,c("min", "max", "mean")]
rownames(stat_NN) <- c("TSP_48", "TSP_76", "TSP_127")
stat_NN
```

W tabelce widzimy najkrótsze ścieżki otrzymane dla poszczególnych TSP.

* **TSP_48**

```{r, echo=FALSE}
NN_tsp48$Punkt[NN_tsp48$Wynik == min(NN_tsp48$Wynik)]
NN_tsp48[c(10,35),]
```

Długość ścieżki wyniosła **12012** i jest to gorszy wynik od Solvera o **1144**. Średni wynik również jest gorszy. Ten wynik został uzyskany dla 2 punktów początkowych: 10 i 35.

* **TSP_76**

```{r, echo=FALSE}
NN_tsp76$Punkt[NN_tsp76$Wynik == min(NN_tsp76$Wynik)]
NN_tsp76[16,]
```

Długość ścieżki wyniosła **130921** i jest to gorszy wynik od Solvera o **12627.5**. Średni wynik również jest gorszy. Wynik ten udało się uzyskać dla punktu początkowego 16.

* **TSP_127**

```{r, echo=FALSE}
NN_tsp127$Punkt[NN_tsp127$Wynik == min(NN_tsp127$Wynik)]
NN_tsp127[117,]
```

Długość ścieżki wyniosła **133970.6** i jest to lepszy wynik od Solvera o **6247**. Średni wynik tutaj też jest gorszy. Wynik ten udało się uzyskać dla punktu początkowego 117.

Za pomocą tego algorytmu nie udało się uzyskać lepszych wyników niż Solver dla TSP_48 i TSP_76.

# Algorytm wspinaczki z multistartem (IHC)

<div style='text-align: justify'>
**Algorytm iteracyjnej wspinaczki** to technika optymalizacyjna, stosowana do znajdowania zbliżonych do optymalnych rozwiązań problemów, które mogą mieć wiele lokalnych minimów. Wykorzystuje on podejście algorytmu wspinaczki, rozszerzone o wielokrotne losowanie różnych początkowych rozwiązań, co zwiększa szansę na znalezienie 
rozwiązania bliskiego globalnemu optimum.
</div>

<<<<<<< HEAD
## Badane parametry


W ramach algorytmu iteracyjnej wspinaczki badane są następujące parametry:

 - **`liczba punktów początkowych`** - maksymalna liczba losowych punktów początkowych, z których algorytm rozpoczyna wspinaczkę
 
 - **`rodzaj sąsiedztwa`** - metoda generowania nowych rozwiązań na podstawie aktualnego rozwiązania. W badaniu uwzględniono typy:
 
    - **`swap`** nowe rozwiązanie powstaje poprzez zamianę miejscami dwóch miast w bieżącej trasie
    
    - **`insertion`** polega na wyborze jednego miasta z danej trasy, usunięciu go z jego pierwotnej pozycji, a następnie wstawieniu go w inne, wybrane miejsce w tej samej trasie
    
    - **`2-opt`** wiąże się z odwróceniem segmentu trasy między dwoma wybranymi wierzchołkami, co prowadzi do zmiany kolejności miast w tym segmencie
  
    <p style="margin-top: 10px;">
 - **`czas działania`** - czas, jaki posiada algorytm na znalezienie rozwiązania
 
 - **`liczba iteracji bez poprawy`** - liczba iteracji, po której algorytm kończy działanie, jeśli nie znaleziono lepszego rozwiązania
 
 - **`liczba iteracji wspinaczki`** - liczba iteracji, jaką algorytm może wykonać w jednej próbie wspinaczki
    </p>


=======
>>>>>>> d2d616ca7c243c7370a932c94612a3612908bc57

# Algorytm symulowanego wyżarzania (SA)

<div style='text-align: justify'>
**Algorytm symulowanego wyżarzania** (ang. Simulated Annealing, SA) jest iteracyjną metodą optymalizacji, która rozpoczyna się od losowego rozwiązania i w każdej iteracji wprowadza zmiany w obrębie sąsiedztwa. Inspiracją dla algorytmu SA był proces metalurgiczny, w którym metal w wysokich temperaturach łatwiej poddaje się obróbce plastycznej. W miarę obniżania temperatury, zmiany kształtu stają się coraz trudniejsze. Podobnie, w algorytmie symulowanego wyżarzania na początku akceptowane są ruchy prowadzące do gorszych rozwiązań z relatywnie dużym prawdopodobieństwem, gdy temperatura jest wysoka. Z upływem iteracji oraz spadkiem temperatury, prawdopodobieństwo akceptacji gorszych rozwiązań maleje, co skutkuje tym, że algorytm niemal zawsze odrzuca pogarszające ruchy. Mechanizm ten ma na celu unikanie utknięcia w ekstremach lokalnych. W każdej iteracji generowane są losowe ruchy, a ich liczba jest 
parametryzowana w danej implementacji. 
</div>

## Badane parametry

W ramach algorytmu symulowanego wyżarzania badane są następujące parametry:

 - **`temperatura początkowa`** -  wartość temperatury, od której rozpoczyna się proces chłodzenia w algorytmie
 
 - **`temperatura końcowa`** - wartość temperatury, do której algorytm będzie dążył w trakcie działania
 
 - **`rodzaj sąsiedztwa`** - metoda generowania nowych rozwiązań na podstawie aktualnego rozwiązania. W badaniu uwzględniono typy:
 
    - `swap` nowe rozwiązanie powstaje poprzez zamianę miejscami dwóch miast w bieżącej trasie
    
    - `insertion` polega na wyborze jednego miasta z danej trasy, usunięciu go z jego pierwotnej pozycji, a następnie wstawieniu go w inne, wybrane miejsce w tej samej trasie
    
    - `2-opt` wiąże się z odwróceniem segmentu trasy między dwoma wybranymi wierzchołkami, co prowadzi do zmiany kolejności miast w tym segmencie
  
    <p style="margin-top: 10px;">
 - **`czas działania`** - limit czasu, jaki posiada algorytm na znalezienie rozwiązania
 
 - **`prędkość chłodzenia`** -  szybkość, z jaką zmniejszana jest temperatura w trakcie działania algorytmu
 
 - **`temperatura minimalna`** - wartość temperatury, poniżej której algorytm nie będzie już kontynuował poszukiwań
    </p>
    
```{r echo=FALSE, include=FALSE}
# SA_compare_methods <- read_excel("C:/Users/user/Downloads/SA.xlsx", 
#     sheet = "Porównanie_metod")
# SA_max_iterations <- read_excel("C:/Users/user/Downloads/SA.xlsx", 
#     sheet = "max_iterations")
# SA_min_temp <- read_excel("C:/Users/user/Downloads/SA.xlsx", 
#     sheet = "min_tem")
# SA_cooling_rate <- read_excel("C:/Users/user/Downloads/SA.xlsx", 
#     sheet = "cooling_rate")
# SA_initial_temp <- read_excel("C:/Users/user/Downloads/SA.xlsx", 
#     sheet = "initial_temp")

SA_clasic <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/SA.xlsx", 
    sheet = "Basic")
SA_move_type <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/SA.xlsx", 
    sheet = "move_type")
SA_initial_temp <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/SA.xlsx", 
    sheet = "initial_temperature")
SA_cooling_rate <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/SA.xlsx", 
    sheet = "cooling_rate")
SA_max_iterations <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/SA.xlsx", 
    sheet = "max_iterations")
SA_min_temp <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/SA.xlsx", 
    sheet = "min_temperature")
```

## Klasyczne

Za podstawowe dane przyjmujemy :

* initial_temperature = 10000

* cooling_rate = 0.99

* max_iterations = 10000

* min_temperature = 0.00001

* time_limit = `None`

* move_type = `two_opt`

```{r, echo=FALSE}
SA_clasic_tsp48 <- SA_clasic %>%
  filter(DATASET == "DATA1") %>%
  select(WYNIK) %>%
  as.data.frame()

SA_clasic_tsp76 <- SA_clasic %>%
  filter(DATASET == "DATA2") %>%
  select(WYNIK) %>%
  as.data.frame()

SA_clasic_tsp127 <- SA_clasic %>%
  filter(DATASET == "DATA3") %>%
  select(WYNIK) %>%
  as.data.frame()

SA_clasic_wyniki <- cbind(SA_clasic_tsp48)
SA_clasic_wyniki <- cbind(SA_clasic_wyniki, SA_clasic_tsp76)
SA_clasic_wyniki <- cbind(SA_clasic_wyniki, SA_clasic_tsp127)

colnames(SA_clasic_wyniki) <- c("TSP_48", "TSP_76", "TSP_127")
SA_clasic_wyniki
```

```{r, echo=FALSE}
SA_clasic_stat <- SA_clasic %>%
  group_by(DATASET) %>%
  summarise(
    Mean = mean(WYNIK),
    Min = min(WYNIK),
    Max = max(WYNIK)
  ) %>%
  as.data.frame()              

rownames(SA_clasic_stat) <- c("TSP_48", "TSP_76", "TSP_127")

SA_clasic_stat[,c("Min", "Max", "Mean")]
```

Powyżej w tabelkach możemy zobaczyć uzyskane wyniki dla algorytmu symulowanego wyżarzania oraz minimalną, maksymalną i średnią wartość. Otrzymane wyniki są zdecydowanie wyższe niż te uzyskane przez Solver. Zwłaszcza dla TSP_127 minimalna wartość jest praktycznie większa o 100 tys. Średnie również znacząco przewyższają uzyskane przez Solver.

```{r, echo=FALSE, warning=FALSE, message=FALSE}
SA_clasic_time <- SA_clasic %>%
  group_by(DATASET) %>%
  select(CZAS) %>%
  summarise(
    Min = min(CZAS),
    Max = max(CZAS),
    Mean = mean(CZAS)
  ) %>% 
  as.data.frame()
  
rownames(SA_clasic_time) <- c("TSP_48", "TSP_76", "TSP_127")

SA_clasic_time[,2:4]
```

Uzyskane czasy przy podstawowych parametrach są bardzo niskie. W Solverze były one zdecydowanie wyższe. w każdym  z przypadków.

## Rodzaj ruchu

Poniżej zbadany został wpływ rodzaju ruchu na długość ścieżki:

```{r, echo=FALSE}
SA_move_type_tsp48 <- SA_move_type %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

SA_move_type_tsp76 <- SA_move_type %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

SA_move_type_tsp127 <- SA_move_type %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(SA_move_type_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Typ ruchu",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
SA_move_type_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Widzimy, że sposób w jaki generujemy sąsiadów a algorytmie ma tutaj duże znaczenie. Wyniki są najgorsze w przypadku `swap` - średnia jest bardzo wysoka. Natomiast mediana i średnia długości ścieżki są najniższe w przypadku ruchu `2-opt`. 

```{r, echo=FALSE}
ggplot(SA_move_type_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Typ ruchu",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
SA_move_type_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_76 pojawiła się analogiczna sytuacja. Dla `2-opt` wyniki są najlepsze, aczkolwiek i tak zdecydowanie gorsze niż te uzyskane przez Solver (średnia jest wyższa o 40 tys.). Najgorzej wypada `swap`. 

```{r, echo=FALSE}
ggplot(SA_move_type_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Typ ruchu",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
SA_move_type_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Tutaj sytuacja analogiczna. Jest jedynie już mniejsza różnica, pomiędzy medianą i średnią długości ścieżki dla `swap` i `insertion`. Wykorzystanie tych dwóch rodzajó ruchów bardzo pogorszyło wyniki, średnia przekroczyła aż 300 tys.

Jest tu dobrze widoczna zależność, że najkrótsza średnia i mediana długości ścieżki są w przypadku typu ruchu `2-opt`. Jednak w każdym z przypadków otrzymane wyniki były zdecydowanie gorsze niż te z Solvera.

## Temperatura początkowa

Poniżej zbadany został wpływ temperatury początkowej na długość ścieżki:

```{r, echo=FALSE}
SA_initial_temp_tsp48 <- SA_initial_temp %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

SA_initial_temp_tsp76 <- SA_initial_temp %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

SA_initial_temp_tsp127 <- SA_initial_temp %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(SA_initial_temp_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Temperatura początkowa",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
SA_initial_temp_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Z wykresów pudełkowych nie widać żadnej zależności. Mediana i średnia długości ścieżki wahają się na podobnym poziomie dla różnych wartości parametru. Temperatura początkowa wydaję się nie mieć dużego znaczenia.

```{r, echo=FALSE}
ggplot(SA_initial_temp_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Temperatura początkowa",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
SA_initial_temp_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_76 pojawiają się już większe wahania, ale nadal dla nie widać, żeby w zależności od temperatury mediana długości ścieżki rosła, bądź malała. Nie mamy tutaj też bardzo dużych odstępstw tzn. średnie i mediany są dość zbliżone do siebie. Otrzymane wyniki są już lepsze niż te uzyskane z podstawowych wartości parametrów czy też poprzez zmianę parametru rodzaju ruchu, ale nadal gorsze od tych z Solvera. 

```{r, echo=FALSE}
ggplot(SA_initial_temp_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Temperatura początkowa",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
SA_initial_temp_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_127 pojawia się widoczny spadek mediany długości ścieżki, jednak jest on tylko do wartości parametru = 10 tys. Następnie zaczyna ona delikatnie rosnąć, ale wartości i tak są lepsze niż te dla niskich początkowych temperatur. Średnia jest dlaje bardzo wysoka. Zmiana tego parametru nie poprawiła wyników.

Wpływ początkowej temperatury nie wydaje się być duży. Dopiero dla dużej liczby miast pojawiły się niższe mediany długości ścieżki dla wyższych temperatur. W pozostałych przypadkach nie było to widoczne. Wyniki nadal nie są zadowalające. Dla TSP_127 widać, że algorytm ma problem z uzyskaniem niższych wyników.

## Prędkość chłodzenia

Poniżej zbadany został wpływ prędkości chłodzenia na długość ścieżki:

```{r, echo=FALSE}
SA_cooling_rate_tsp48 <- SA_cooling_rate %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

SA_cooling_rate_tsp76 <- SA_cooling_rate %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

SA_cooling_rate_tsp127 <- SA_cooling_rate %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(SA_cooling_rate_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Prędkość chłodzenia",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
SA_cooling_rate_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

```{r, echo=FALSE}
ggplot(SA_cooling_rate_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Prędkość chłodzenia",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
SA_cooling_rate_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

```{r, echo=FALSE}
ggplot(SA_cooling_rate_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Prędkość chłodzenia",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
SA_cooling_rate_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

## Liczba iteracji



## Minimalna temperatura



## Podsumowanie



# Algorytm przeszukiwania tabu

<div style='text-align: justify'>
**Algorytm przeszukiwania tabu** (ang. Tabu Search, TS) to algorytm, który opiera się na stopniowym ulepszaniu początkowego, losowego rozwiązania. W przypadku problemu komiwojażera algorytm stara się skrócić trasę w taki sposób, aby odwiedzić wszystkie punkty. TS działa w sposób iteracyjny – w każdej iteracji obecne rozwiązanie jest modyfikowane poprzez wybór jednego z ruchów zdefiniowanych w sąsiedztwie. Charakterystyczną cechą algorytmu TS jest lista tabu, która przechowuje ruchy wykonane w ostatnich iteracjach. Ruchy te są czasowo zakazane, co zapobiega zapętleniu się algorytmu i ponownemu odwiedzaniu tych samych rozwiązań. Algorytm pozwala również na wykonanie ruchu, który chwilowo pogarsza rozwiązanie. Taki mechanizm umożliwia ucieczkę z lokalnych ekstremów i zwiększa szansę na znalezienie rozwiązania globalnie optymalnego lub bliskiego optymalnemu. Dodatkowo TS może korzystać z kryterium zakończenia działania, które przerywa algorytm, jeśli przez dłuższy czas nie nastąpi poprawa wyniku.
</div>

## Badane parametry

W ramach algorytmu przeszukiwania tabu badane są następujące parametry:

 - **`długość listy tabu`** - liczba wykonanych ruchów, które nie mogą być ponownie wykorzystanie przez określoną liczbę iteracji
 
 - **`liczba iteracji bez poprawy`** - liczba iteracji, po której algorytm kończy działanie, jeśli nie znaleziono lepszego rozwiązania
 
 - **`rodzaj sąsiedztwa`** - metoda generowania nowych rozwiązań na podstawie aktualnego rozwiązania. W badaniu uwzględniono typy:
 
    - `swap` nowe rozwiązanie powstaje poprzez zamianę miejscami dwóch miast w bieżącej trasie
    
    - `insertion` polega na wyborze jednego miasta z danej trasy, usunięciu go z jego pierwotnej pozycji, a następnie wstawieniu go w inne, wybrane miejsce w tej samej trasie
    
    - `2-opt` wiąże się z odwróceniem segmentu trasy między dwoma wybranymi wierzchołkami, co prowadzi do zmiany kolejności miast w tym segmencie
  
    <p style="margin-top: 10px;">
 - **`czas działania`** - limit czasu, jaki posiada algorytm na znalezienie rozwiązania
    </p>

```{r echo=FALSE, include=FALSE}
TS_clasic <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/TS.xlsx", 
    sheet = "Basic")
TS_move_generator <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/TS.xlsx", 
    sheet = "move_generator")
TS_list_length <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/TS.xlsx", 
    sheet = "tabu_list_length")
TS_max_iterations <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/TS.xlsx", 
    sheet = "max_iterations")
TS_max_no_improve <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/TS.xlsx", 
    sheet = "max_no_improve")
TS_time_limit <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/TS.xlsx", 
    sheet = "time_limit")
```

## Klasyczny

Za podstawowe dane przyjmujemy:

* tabu_list_length = 10

* max_iterations = 10000

* max_no_improve = 50

* move_type = `two_opt`

* time_limit = 1000

```{r, echo=FALSE}
TS_clasic_tsp48 <- TS_clasic %>%
  filter(DATASET == "DATA1") %>%
  select(WYNIK) %>%
  as.data.frame()

TS_clasic_tsp76 <- TS_clasic %>%
  filter(DATASET == "DATA2") %>%
  select(WYNIK) %>%
  as.data.frame()

TS_clasic_tsp127 <- TS_clasic %>%
  filter(DATASET == "DATA3") %>%
  select(WYNIK) %>%
  as.data.frame()

TS_clasic_wyniki <- cbind(TS_clasic_tsp48)
TS_clasic_wyniki <- cbind(TS_clasic_wyniki, TS_clasic_tsp76)
TS_clasic_wyniki <- cbind(TS_clasic_wyniki, TS_clasic_tsp127)

colnames(TS_clasic_wyniki) <- c("TSP_48", "TSP_76", "TSP_127")
TS_clasic_wyniki
```

```{r, echo=FALSE}
TS_clasic_stat <- TS_clasic %>%
  group_by(DATASET) %>%
  summarise(
    Mean = mean(WYNIK),
    Min = min(WYNIK),
    Max = max(WYNIK)
  ) %>%
  as.data.frame()              

rownames(TS_clasic_stat) <- c("TSP_48", "TSP_76", "TSP_127")

TS_clasic_stat[,c("Min", "Max", "Mean")]
```

```{r, echo=FALSE}
TS_clasic_time <- TS_clasic %>%
  group_by(DATASET) %>%
  select(CZAS) %>%
  summarise(
    Min = min(CZAS),
    Max = max(CZAS),
    Mean = mean(CZAS)
  ) %>% 
  as.data.frame()
  
rownames(TS_clasic_time) <- c("TSP_48", "TSP_76", "TSP_127")

TS_clasic_time[,2:4]
```

## Rodzaje ruchów

Poniżej zbadany został wpływ rodzaju ruchu na długość ścieżki:

```{r, echo=FALSE}
TS_move_generator_tsp48 <- TS_move_generator %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

TS_move_generator_tsp76 <- TS_move_generator %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

TS_move_generator_tsp127 <- TS_move_generator %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(TS_move_generator_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Typ ruchu",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
TS_move_generator_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

```{r, echo=FALSE}
ggplot(TS_move_generator_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Typ ruchu",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
TS_move_generator_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

```{r, echo=FALSE}
ggplot(TS_move_generator_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Typ ruchu",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
TS_move_generator_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```


## Liczba iteracji

Poniżej zbadany został wpływ liczby iteracji na długość ścieżki:

```{r, echo=FALSE}
TS_max_iterations_tsp48 <- TS_max_iterations %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

TS_max_iterations_tsp76 <- TS_max_iterations %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

TS_max_iterations_tsp127 <- TS_max_iterations %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(TS_max_iterations_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Liczba iteracji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
TS_max_iterations_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

```{r, echo=FALSE}
ggplot(TS_max_iterations_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Liczba iteracji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
TS_max_iterations_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

```{r, echo=FALSE}
ggplot(TS_max_iterations_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Liczba iteracji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
TS_max_iterations_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

## Liczba iteracji bez poprawy

Poniżej zbadany został wpływ liczby iteracji bez poprawy na długość ścieżki:

```{r, echo=FALSE}
TS_max_no_improve_tsp48 <- TS_max_no_improve %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

TS_max_no_improve_tsp76 <- TS_max_no_improve %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

TS_max_no_improve_tsp127 <- TS_max_no_improve %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(TS_max_no_improve_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Liczba iteracji bez poprawy",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
TS_max_no_improve_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

```{r, echo=FALSE}
ggplot(TS_max_no_improve_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Liczba iteracji bez poprawy",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
TS_max_no_improve_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

```{r, echo=FALSE}
ggplot(TS_max_no_improve_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Liczba iteracji bez poprawy",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
TS_max_no_improve_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

## Limit czasowy

Poniżej zbadany został wpływ liczby iteracji bez poprawy na długość ścieżki:

```{r, echo=FALSE}
TS_time_limit_tsp48 <- TS_time_limit %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

TS_time_limit_tsp76 <- TS_time_limit %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

TS_time_limit_tsp127 <- TS_time_limit %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(TS_time_limit_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Limit czasowy",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
TS_time_limit_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

```{r, echo=FALSE}
ggplot(TS_time_limit_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Limit czasowy",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
TS_time_limit_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

```{r, echo=FALSE}
ggplot(TS_time_limit_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Limit czasowy",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
TS_time_limit_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

## Podsumowanie



# Algorytm genetyczny

<div style='text-align: justify'>
**Algorytm genetyczny** (ang. Genetic Algorithm, GA) to technika optymalizacyjna, która przeszukuje przestrzeń możliwych rozwiązań danego problemu, wykorzystując elementy losowe w celu znalezienia najlepszego rozwiązania. Jego działanie naśladuje proces ewolucji biologicznej. Początkowa populacja rozwiązań poddawana jest serii operacji, takich jak krzyżowanie oraz mutacje, co prowadzi do powstania nowej generacji. Proces ten jest powtarzany wielokrotnie, 
aż do osiągnięcia określonej liczby iteracji lub spełnienia innych warunków stopu. 
</div>

## Badane parametry

W ramach algorytmu genetycznego badane są następujące parametry:

 - **`wielkość populacji`** - liczba osobników w populacji, które będą brane pod uwagę w danej iteracji algorytmu
 
 - **`prawdopodobieństwo mutacji`** - prawdopodobieństwo z jakim nastąpi mutacja genów w osobnikach
 
 - **`prawdopodobieństwo krzyżowania`** - prawdopodobieństwo z jakim nastąpi krzyżowanie osobników w populacji
 
 - **`metoda doboru rodziców`** - sposób wyboru najlepszych osobników do reprodukcji:
 
   - `turniejowy` - losowana jest grupa osobników stanowiąca 10% populacji, a jako rodzic wybierany jest osobnik z najkrótszą trasą
   
   - `rankingowy` - wybór rodzica odbywa się na podstawie rankingu osobników, przy czym zwracana jest tylko jedna ścieżka
   
   <p style="margin-top: 10px;">
 - **`metoda krzyżowania`** - sposób łączenia genów (tras) rodziców w celu stworzenia potomków:
 
   - `order crossover (OX)` - z pierwszego rodzica wybierany jest losowy segment miast, który jest kopiowany do potomka w to samo miejsce, pozostałe miasta są uzupełniane w potomku zgodnie z ich kolejnością wystąpienia w drugim rodzicu
   
   - `partially matched crossover (pmx)` - dziedziczenie części trasy od każdego z rodziców przy zachowaniu oryginalnej kolejności odwiedzonych miast, jednocześnie eliminując duplikaty w nowo powstałym rozwiązaniu 
   </p>
   
   <p style="margin-top: 10px;">
 - **`metoda mutacji`** - metoda generowania nowych rozwiązań na podstawie aktualnego rozwiązania. W badaniu uwzględniono typy:
 
    - `swap` nowe rozwiązanie powstaje poprzez zamianę miejscami dwóch miast w bieżącej trasie
    
    - `insertion` polega na wyborze jednego miasta z danej trasy, usunięciu go z jego pierwotnej pozycji, a następnie wstawieniu go w inne, wybrane miejsce w tej samej trasie
    
    - `inversion` odwrócenie kolejności odwiedzanych miast w wybranym segmencie trasy
    </p>
    
    <p style="margin-top: 10px;">
 - **`liczba pokoleń`** - liczba iteracji algorytmu 
    </p>
    
```{r echo=FALSE, include=FALSE}

```

# Algorytm mrówkowy

<div style='text-align: justify'>
 Algorytm mrówkowy został stworzony na podstawie obserwacji życia mrówek podczas szukania optymalnej drogi między mrowiskiem a źródłem pożywienia. Mrówki w środowisku naturalnym poruszają się losowo, ale zostawiają na swojej drodze feromony, które pomagają innym mrówkom znaleźć najkrótszą ścieżkę. Z czasem feromony parują (ich wpływ maleje), co pozwala wyeliminować nieoptymalne ścieżki. Algorytm ten dobrze sprawdza się w rozwiązywaniu problemu komiwojażera.
</div>

Zasada działania algorytmu do rozwiązania problemu komiwojażera wygląda następująco:

1. Połączenie między miastami inicjowane są niewielką ilością feromonu.

2. Każda mrówka umieszczana jest losowo w wybranym mieście, z którego przemieszcza się do kolejnego z prawdopodobieństwem P, będącym funkcją odległości do celu oraz wielkości śladu feromonowego pozostawionego na krawędzi łączącej je z tym miastem.

3. Mrówka poruszając się z miasta i do miasta j pozostawia za sobą ślad feromonowy odwrotnie proporcjonalny do długości trasy, którą przebyła .

4. Sztuczna mrówka wyposażona jest w pamięć w celu zapamiętania, które miasto już odwiedziła, aby uwzględnić je tylko jeden raz w swojej trasie (pamięć jest czyszczona przy rozpoczęciu każdego kolejnego cyklu przechodzenia).

5. Dla odwzorowania parowania feromonu występującego w naturze, w algorytmie feromon jest pomniejszany o określoną wartość po każdej iteracji, tak aby uniknąć zjawiska przedwczesnej zbieżności algorytmu.

## Parametry

* num_ants - liczba mrówek, która bierze udział w szukaniu optymalnej trasy. Jest ona zależna od liczby miast i wybierana z przedziału (0.5 * liczba miast, 2 * liczba miast)

* num_iterations - liczba iteracji

* alpha - parametr sterujący ważnością intensywności śladu feromonowego

* beta - parametr sterujący ważnością widoczności następnego
miasta

* rho - prędkość odparowywania feromonu

## Klasyczne 

Za podstawowe wartości parametrów przyjmujemy:

* num_ants = 10

* num_iterations = 100

* alpha = 1

* beta = 2

* rho = 0.5

```{r, echo=FALSE, include=FALSE}
klasyk_wyniki <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/ACO.xlsx", 
    sheet = "Klasyk_wyniki")
num_ants <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/ACO.xlsx", 
    sheet = "num_ants")
max_it <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/ACO.xlsx", 
    sheet = "max_it")
alpha <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/ACO.xlsx", 
    sheet = "alpha")
beta <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/ACO.xlsx", 
    sheet = "beta")
rho <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/ACO.xlsx", 
    sheet = "rho")
```

```{r, echo=FALSE}
klasyk_mrowki_tsp48 <- klasyk_wyniki %>%
  filter(DATASET == "DATA1") %>%
  select(WYNIK) %>%
  as.data.frame()

klasyk_mrowki_tsp76 <- klasyk_wyniki %>%
  filter(DATASET == "DATA2") %>%
  select(WYNIK) %>%
  as.data.frame()

klasyk_mrowki_tsp127 <- klasyk_wyniki %>%
  filter(DATASET == "DATA3") %>%
  select(WYNIK) %>%
  as.data.frame()

klasyk <- cbind(klasyk_mrowki_tsp48)
klasyk <- cbind(klasyk, klasyk_mrowki_tsp76)
klasyk <- cbind(klasyk, klasyk_mrowki_tsp127)

colnames(klasyk) <- c("TSP_48", "TSP_76", "TSP_127")
klasyk
```

```{r, echo=FALSE}
klasyk_stat <- klasyk_wyniki %>%
  group_by(DATASET) %>%
  summarise(
    Mean = mean(WYNIK),
    Min = min(WYNIK),
    Max = max(WYNIK)
  ) %>%
  as.data.frame()              

rownames(klasyk_stat) <- c("TSP_48", "TSP_76", "TSP_127")

klasyk_stat[,c("Min", "Max", "Mean")]
```

W tabelce widzimy statystyki uzyskane dla podstawowych wartości parametrów dla algorytmu mrówkowego. Dla TSP_48 i TSP_76 wartości minimalne są wyższe niż uzyskane przez Solver. Jedynie dla TSP_127 otrzymany wynik jest lepszy. Natomiast średnie są dość podobne.

**Czas**

```{r, echo=FALSE, warning=FALSE, message=FALSE}
ACO_clasic_time <- klasyk_wyniki %>%
  group_by(DATASET) %>%
  select(CZAS) %>%
  summarise(
    Min = min(CZAS),
    Max = max(CZAS),
    Mean = mean(CZAS)
  ) %>% 
  as.data.frame()
  
rownames(ACO_clasic_time) <- c("TSP_48", "TSP_76", "TSP_127")

ACO_clasic_time[,2:4]
```

Średnie czasy trwania agorytmu są dość niskie. Jednak zwiększają się w zależności od liczby miast.

## Liczba mrówek

Poniżej zbadany został wpływ liczby mrówek na długość ścieżki:

```{r, echo=FALSE}
num_ants_mrowki_tsp48 <- num_ants %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

num_ants_mrowki_tsp76 <- num_ants %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

num_ants_mrowki_tsp127 <- num_ants %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(num_ants_mrowki_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Liczba mrówek",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
num_ants_mrowki_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_48 możemy zobaczyć zobaczyć z wykresów pudełkowcyh, że wraz ze wzrostem liczby mrówek, która bierze udział w poszukiwaniu optymalnej trasy, mediana długości ścieżki zdecydowanie się obniża. Średnia również widocznie maleje. Najniższa jest dla liczby mrówek równej 84. 

```{r, echo=FALSE}
ggplot(num_ants_mrowki_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Liczba mrówek",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
num_ants_mrowki_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_76 pojawia nam się podobna zależność. Mediana długości ścieżki widocznie się obniża i największe różnice widać na początku. Później te różnice nie są już takie znaczące. Uzyskane średnie dla wszystkich wartości parametrów są niższe niż średnia z Solvera (139999,45).

```{r, echo=FALSE}
ggplot(num_ants_mrowki_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Liczba mrówek",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
num_ants_mrowki_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_127 nie możemy już zobaczyć, tej zależności, że mediana i średnia długości ścieżki maleje wraz ze wzrostem liczby mrówek. Widzimy tutaj, że raz rośnie raz maleje. Średnia długość ścieżki co prawda zmalała od wartości parametru 123, jednak później wraz ze wzrostem jego wartości waha się i nie zmniejsza się znacząco. 

W 2/3 przypadki wskazały, że wraz ze wzrostem liczby mrówek mediana i średnia długości ścieżki maleje. Warto też dodać, że średnie wyniki są lepsze w każdym z przypadków niż te otrzymane dla klasycznych wyników, gdzie liczba mrówek wynosiła 10.

## Liczba iteracji

Poniżej został zbadany wpływ liczby iteracji na długość ścieżki:

```{r, echo=FALSE}
max_it_mrowki_tsp48 <- max_it %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

max_it_mrowki_tsp76 <- max_it %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

max_it_mrowki_tsp127 <- max_it %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(max_it_mrowki_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Liczba iteracji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
max_it_mrowki_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

W przypadku zmian liczby iteracji, nie widać tutaj żadnej zależności. Mediana długości ścieżki raz rośnie raz maleje. Jedyny duży spadek widać na początku. Dla parametrów powyżej wartości 100, mediany już są niższe i średnia również. Poza tym liczba iteracji nie wpływa znacząco na wyniki. 

```{r, echo=FALSE}
ggplot(max_it_mrowki_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Liczba iteracji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
max_it_mrowki_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_76 pojawia się już bardziej widoczna zależność. Mediana i średnia długości ścieżki maleje wraz z liczbą iteracji. Jednak nie w bardzo znaczącym stopniu. Różnice są niewielkie. Pojawia się nam też jeden wyjątek od tej zależności dla liczby iteracji równej 150, gdzie mediana i średnia znacząco spadły. Otrzymane średnie sa niższe niż te otrzymane przez Solver.

```{r, echo=FALSE}
ggplot(max_it_mrowki_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Liczba iteracji",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
max_it_mrowki_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_127 spadek mediany i średniej wraz z wzrostem iteracji jest już bardziej widoczny. Jednak pojawiają się też pewne wahania. W odróżnieniu od poprzednich TSP, widać tutaj, że wraz z wzrostem iteracji maleje również minimalna wartość.

Wpływ liczby iteracji wydaje się być częsciowo uzależniony od liczby miast. Gdy wynosiła ona 48 nie widać było zależności. Wraz z zwiększeniem liczby miast stawała się ona bardziej wyraźna. Jednak pojawiały się wtedy pewne wahania.

## Alpha

Poniżej został zbadany wpływ alphy na długość ścieżki:

```{r, echo=FALSE}
alpha_mrowki_tsp48 <- alpha %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

alpha_mrowki_tsp76 <- alpha %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

alpha_mrowki_tsp127 <- alpha %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```


```{r, echo=FALSE}
ggplot(alpha_mrowki_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Alpha",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
alpha_mrowki_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla wartości alpha równej 0 widać znaczną różnicę w medianie i średniej długości ścieżki w porównaniu do pozostałych wartości. Wynika to z faktu, że alpha odpowiada za wpływ intensywności śladu feromonowego na wybory mrówek. Gdy alpha wynosi 0, ślad feromonowy nie ma żadnego wpływu na ich decyzje. W rezultacie, pomimo istnienia informacji o jakości trasy (beta = 2), brak znaczenia intensywności feromonów sprawia, że mrówki nie są w stanie z niej skorzystać.

W przypadku alpha = 1, wyniki są najniższe. Jest to zapewne z wiązane z tym, że stosunek intensywności do widoczności feromonów jest najlepszy. Natomiast wraz ze wzrostem alpha, długość ścieżki rośnie, ponieważ gdy wartość alpha jest za duża w porównaniu do parametru beta, populacja mrówek traci różnorodność. Różnica mediany i średniej między alpha 3 i 4 jest znikoma. Różnica alphy w stosunku do bety jest na tyle wysoka, że zwiększanie alphy nie wpływa na poprawę, badź pogorszenie długości ścieżki.

```{r, echo=FALSE}
ggplot(alpha_mrowki_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Alpha",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
alpha_mrowki_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Tutaj sytuacja jest praktycznie identyczna. Dla alpha = 0 wyniki są najgorsze. Natomiast wraz ze wzrostem parametru (alpha > beta) wyniki się pogarszają do momentu gdzie nie ma już znaczącej różnicy w wynikach.

```{r, echo=FALSE}
ggplot(alpha_mrowki_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Alpha",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
alpha_mrowki_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_127 analogiczna sytuacja.

Wartość parametru alpha istotnie wpływa na długość ścieżki, a tak naprawdę to jego różnica w stosunku do bety. Gdy jest ona odpowiednia, wyniki są najlepsze (średnia i mediana długości ścieżki sa najniższe). W każdym z przypadku najlepsze wyniki uzyskano dla alpha = 1 (beta = 2). Natomiast wyniki nie są lepsze od tych uzsykanych przez Solver. Średnie są porównywalne bądź gorsze.

## Beta

Poniżej został zbadany wpływ bety na długość ścieżki:

```{r, echo=FALSE}
beta_mrowki_tsp48 <- beta %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

beta_mrowki_tsp76 <- beta %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

beta_mrowki_tsp127 <- beta %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(beta_mrowki_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Beta",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
beta_mrowki_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Największa różnica w wynikach (długościach ścieżek) jest widoczna pomiędzy wartościami beta = 1 i beta = 2. Powodem tego jest fakt, że przy beta = 1 i alpha = 1 wpływ obu parametrów – feromonów (alpha) i heurystyki (beta) – jest równoważny. W takiej sytuacji różnica pomiędzy wpływem tych dwóch czynników jest zerowa, co prowadzi do najgorszych wyników. W przypadku bardziej zróżnicowanych wartości alpha i beta (np. beta = 2), jedna z tych strategii ma większy wpływ, co pozwala mrówkom na bardziej skoncentrowane działania i prowadzi do lepszych wyników. Natomiast gdy wartość bety wzrasta, tylko na początku widać delikatną poprawę w wynikach. Później median i średnia długości ścieżki już są bardzo podobne. Wyniki się nie poprawiają.

```{r, echo=FALSE}
ggplot(beta_mrowki_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Beta",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
beta_mrowki_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Tutaj mamy analogiczną sytuację do poprzedniej. Dla bety = 0 wyniki są najgorsze. Następnie już tylko nieznacznie się wahają. 

```{r, echo=FALSE}
ggplot(beta_mrowki_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Beta",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
beta_mrowki_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_127 wzrost wartości paramaetru powoduje poprawę w wynikach. Średnia i mediana długości ścieżki maleją, aż do momentu gdzie już nie uzyskujemy poprawy i wyniki się tylko nieznacznie wahają wokół podobnej wartości. W tym przypadku wzrost wartości bety spowodował największą poprawę.

Współczynnik bety znacząco wpływa na długość ścieżki. Jednak tak jak było wspomniane przy parametrze alpha, największe znaczenie ma różnica między tymi dwoma parametrami.

## Rho

Poniżej został zbadany wpływ rho na długość ścieżki:

```{r, echo=FALSE}
rho_mrowki_tsp48 <- rho %>%
  filter(DATASET == "DATA1") %>%
  as.data.frame()

rho_mrowki_tsp76 <- rho %>%
  filter(DATASET == "DATA2") %>%
  as.data.frame()

rho_mrowki_tsp127 <- rho %>%
  filter(DATASET == "DATA3") %>%
  as.data.frame()
```

```{r, echo=FALSE}
ggplot(rho_mrowki_tsp48, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_48",
    x = "Rho",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_48**

```{r, echo=FALSE}
rho_mrowki_tsp48 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Wyniki średniej i mediany długości ścieżki wahają się wokół podobnych wartości niezależnie od wartości rho. Jedynie znacząca różnica jest dla rho = 0.9, Średnia i mediana są zdecydowanie wyższe. Uzyskane średnie są zdecydowanie wyższe niż te otrzyamne przez Solver.

```{r, echo=FALSE}
ggplot(rho_mrowki_tsp76, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_76",
    x = "Rho",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_76**

```{r, echo=FALSE}
rho_mrowki_tsp76 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_76 widzimy natomiast, że różnice w średniej i medianie długości ścieżki są zdecydowanie największe w przypadku skrajnych wartości rho. Bardzo niskie wartości tego parametru oznaczają długotrwałe utrzymywanie się feromonów (bardzo wolne odparowywanie) co prowadzi do nadmiernej eksploatacji jednej trasy, co ogranicza zdolność algorytmu do eksploracji nowych, potencjalnie lepszych tras. Natomiast zbyt wysokie wartościpowodują bardzo szybkie odparowywanie feromonów co sprawia, że ślady na trasach szybko zanikają. W tej sytuacji algorytm prawie w ogóle nie korzysta z informacji zgromadzonych przez inne mrówki, ponieważ ślady feromonowe znikają zanim inne mrówki zdążą je wykorzystać. W związku z tym dla wartości rho, które oscylują wokół 0.5 wyniki są lepsze, ale jednocześnie zbliżone do siebie.

```{r, echo=FALSE}
ggplot(rho_mrowki_tsp127, aes(x = as.factor(PARAMETR), y = WYNIK_1)) +
  geom_boxplot(fill = "pink") +
  labs(
    title = "TSP_127",
    x = "Rho",
    y = "Długość ścieżki"
  ) +
  theme_minimal()
```

**TSP_127**

```{r, echo=FALSE}
rho_mrowki_tsp127 %>%
  group_by(PARAMETR) %>%
  summarise(
    Min = min(WYNIK_1),
    Max = max(WYNIK_1),
    Mean = mean(WYNIK_1)
  ) %>%
  as.data.frame() 
```

Dla TSP_127 jest podobna sytuacja ze skrajnymi wartościami. Jednak lepsze są wyniki dla wartości rho trochę niższych niż.

Najbardziej optymalne wyniki są uzyskiwane gdy rho przyjmuję wartości bliższe 0.5 niż skrajne (0.1 czy 0.9). Jednak wyniki nie są lepsze niż te uzyskane przez Solver. Jedynie w przypadku TSP_127 udało się otrzymać krótsze długości ścieżki.

## Podsumowanie

Najlepszy wyniki dla TSP_48 przy zmianie poszczególnych parametrów:

* Klasyk - 11540.0	

* Liczba mrówek - 11181 (liczba mrówek - 44)

* Liczba iteracji - 11128	(liczba iteracji - 400)

* Alpha - 11414	(alpha - 1)

* Beta - 11313 (beta - 6)

* Rho - 11246	(rho - 0.7)

Dla TSP_48 przy użyciu algorytmu mrówkowego nie udało się uzyskać lepszego wyniku niż ten uzyskany przez Solver (10868)

Najlepszy wyniki dla TSP_76 przy zmianie poszczególnych parametrów:

* Klasyk - 124560.0		

* Liczba mrówek - 117472.3 (liczba mrówek - 78)

* Liczba iteracji - 117711.1	(liczba iteracji - 150)

* Alpha - 125278.5	(alpha - 1)

* Beta - 117716.2 (beta - 4)

* Rho - 122202.6	(rho - 0.2)

Dla TSP_76 przy użyciu algorytmu mrówkowego udało się uzyskać dwa lepsze wyniki niż ten uzyskany przez Solver (118293.5)

Najlepszy wyniki dla TSP_127 przy zmianie poszczególnych parametrów:

* Klasyk - 134426.3			

* Liczba mrówek - 123471.0 (liczba mrówek - 203)

* Liczba iteracji - 128085.5	(liczba iteracji - 450)

* Alpha - 136597.7	(alpha - 1)

* Beta - 125936.3 (beta - 7)

* Rho - 131834.5	(rho - 0.5)

Dla TSP_127 przy użyciu algorytmu mrówkowego  udało się uzyskać lepsze wyniku niż ten uzyskany przez Solver (140217.6)

