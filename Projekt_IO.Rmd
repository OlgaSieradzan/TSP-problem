---
title: "Projekt Inteligencja Obliczeniowa"
author: "Justyna Sarkowicz, Olga Sieradzan, Weronika Duda, Amelia Madej, Aleksandra Węgrzyn"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: 
      collapsed: true
      smooth_scroll: true
    toc_font: "Arial"
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo=FALSE, include=FALSE, message=FALSE, warning=FALSE}
library(readxl)
library(ggplot2)
library(gridExtra)
library(psych)
library(patchwork)
```

# Wprowadzenie

Problem komiwojażera (Travelling Salesman Problem, TSP) to jedno z najbardziej znanych i intensywnie badanych zagadnień w dziedzinie optymalizacji kombinatorycznej oraz teorii grafów. W swojej klasycznej formie problem ten polega na znalezieniu najkrótszej możliwej trasy, która odwiedza dokładnie raz każdy z zadanych punktów i powraca do punktu początkowego. TSP znajduje zastosowanie w wielu dziedzinach, takich jak logistyka, planowanie tras, produkcja czy genetyka.

TSP jest problemem należącym do klasy NP-trudnych, co oznacza, że wraz ze wzrostem liczby punktów (miast) liczba możliwych tras rośnie w sposób wykładniczy, a dokładne rozwiązanie staje się coraz trudniejsze do obliczenia w rozsądnym czasie. Z tego powodu opracowanie efektywnych algorytmów heurystycznych i metaheurystycznych, które pozwalają na znalezienie bliskich optymalnym rozwiązań w akceptowalnym czasie.

Celem naszego projektu jest implementacja sześciu różnych algorytmów, które rozwiązują problem komiwojażera

# Solver

Wyniki uzyskane za pomocą zaimplementowanych algorytmów zostaną porównane z tymi uzyskanymi w Solverze. Będzie to nasz benchmark.

```{r, echo=FALSE, include=FALSE}
solver <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/Solver.xlsx")
```

```{r, echo=FALSE}
solver[,c(2,4,6)]
```

W przypadku danych TSP_48 czasy są tutaj dość zbliżone. Najniższy z nich to 92.625 s. Natomiast dla TSP_76 mamy dwie wartości znacząco odstające od pozostałych. Dla TSP_127 czasy są zdecydowanie najdłuższe w stosunku do pozostałych. Nie ma tam tak rozbieżnych wyników jak dla TSP_76. 

## Statystyki

W statystykach poniżej przedstawiono najkrótszą oraz najdłuższą długość ścieżki uzyskaną przez Solver. Mamy również wyciągniętą średnią ze wszystkich wyników.

```{r, echo=FALSE}
sol_tsp48 <- describe(solver$TSP_48)
sol_tsp76 <- describe(solver$TSP_76)
sol_tsp127 <- describe(solver$TSP_127)
sol <- rbind(sol_tsp48)
sol <- rbind(sol, sol_tsp76)
sol <- rbind(sol, sol_tsp127)
sol <- sol[ ,c("min", "max", "mean")]
rownames(sol) <- c("TSP_48", "TSP_76", "TSP_127")
sol
```

Będzie to nasz benchmark, do którego będziemy odnosić wyniki uzyskane przez pozostałe algorytmy.

# Algorytmu Najbliższego Sąsiada (NN)

Tutaj opisać algorytm jak działa

## Parametry

Tutaj opisać jakie mamy parametry

## Rodzaje ruchów

Tutaj opisać jakie mamy

## Zestawienie wyników

wypisanie czasu wykonania danego algorytmu

### Porównanie metod

```{r, echo=FALSE, include=FALSE}
porownanie_metod_tsp48 <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/NN.xlsx", 
    sheet = "Porównanie_metod+1")
max_iteration_tsp48 <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/NN.xlsx", 
    sheet = "max_iterations_1")
restart_tsp48 <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/NN.xlsx", 
    sheet = "Restart_1")
point_tsp48 <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/NN.xlsx", 
    sheet = "Point_1")

porownanie_metod_tsp76 <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/NN.xlsx", 
    sheet = "Porównanie_metod_2")
max_iteration_tsp76 <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/NN.xlsx", 
    sheet = "max_iterations_2")
restart_tsp76 <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/NN.xlsx", 
    sheet = "Restart_2")
point_tsp76 <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/NN.xlsx", 
    sheet = "Point_2")

porownanie_metod_tsp127 <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/NN.xlsx", 
    sheet = "Porównanie_metod_3")
max_iteration_tsp127 <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/NN.xlsx", 
    sheet = "max_iterations_3")
restart_tsp127 <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/NN.xlsx", 
    sheet = "Restart_3")
point_tsp127 <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/NN.xlsx", 
    sheet = "Point_3")
```

Stałe parametry:

* start_point = 0

* max_time = 500

* random_restart = 1

* max_iteration = 150

```{r, echo=FALSE}
p1 <- ggplot(porownanie_metod_tsp48, aes(x = reorder(Metoda, -`Długość ścieżki`), y = `Długość ścieżki`, fill = Metoda)) +
  geom_col() +
  geom_text(aes(label = `Długość ścieżki`), vjust = 2, color = "black", size = 3.2) + 
  labs(
    title = "TSP_48",
    x = "Metoda",
    y = "Długość ścieżki"
  ) +
  theme_minimal()

p2 <- ggplot(porownanie_metod_tsp76, aes(x = reorder(Metoda, -`Długość ścieżki`), y = `Długość ścieżki`, fill = Metoda)) +
  geom_col() +
  geom_text(aes(label = round(`Długość ścieżki`,1)), vjust = 2, color = "black", size = 3.2) + 
  labs(
    title = "TSP_76",
    x = "Metoda",
    y = "Długość ścieżki"
  ) +
  theme_minimal()

p3 <- ggplot(porownanie_metod_tsp127, aes(x = reorder(Metoda, -`Długość ścieżki`), y = `Długość ścieżki`, fill = Metoda)) +
  geom_col() +
  geom_text(aes(label = round(`Długość ścieżki`,1)), vjust = 2, color = "black", size = 3.2) + 
  labs(
    title = "TSP_127",
    x = "Metoda",
    y = "Długość ścieżki"
  ) +
  theme_minimal()

(p1 + p2 + p3) +
  plot_layout(guides = "collect", ncol = 2) +  # Wspólna legenda, układ 2 kolumny
  plot_annotation(title = "Długość ścieżki w zależności od rodzaju ruchu")
```

Na wykresach możemy zobaczyć jak w zależności od metody zmieniała się długość ścieżki. Dla każdego TSP najwyższe wartości są otrzymywane przy użyciu klasycznego algorytmu. Natomiast w dwóch przypadkach najlepszy wynik został uzyskany gdy algorytm skorzystał z ruchu 2-opt. Dla TSP_48 i TSP_76 widać, że znacząco dobrze wypadł w odniesieniu do pozostałych. Wykorzystanie ruchu insertion dobrze się sprawdziło w szczegółności dla TSP_127. Jednak jest nie wielka różnica pomiędzy obiema metodami.

```{r, echo=FALSE}
por_st48 <- describe(porownanie_metod_tsp48$`Długość ścieżki`)
por_st76 <- describe(porownanie_metod_tsp76$`Długość ścieżki`)
por_st127 <- describe(porownanie_metod_tsp127$`Długość ścieżki`)
por_st <- rbind(por_st48)
por_st <- rbind(por_st, por_st76)
por_st <- rbind(por_st, por_st127)
por_st <- por_st[ ,c("min", "max", "mean")]
rownames(por_st) <- c("TSP_48", "TSP_76", "TSP_127")
por_st
```

W odniesieniu do Solvera, możemy zobaczyć, że dla TSP_76 i TSP_127 uzyskane wyniki są niższe. Natomiast dla TSP_48 wynik jest delikatnie wyższy. Średnie nie różnią się znacząco od tych z Solvera.

### Liczba iteracji

Stałe parametry:

* start_point = 0

* max_time = 500

* random_restart = 1

```{r, echo=FALSE, warning=FALSE}
m1 <- ggplot(max_iteration_tsp48, aes(x = PARAMETR, y = WYNIK)) +
  geom_line(colour = "pink", size = 1) +
  labs(
    title = "TSP_48",
    x = "Liczba iteracji",
    y = "Długość ścieżki"
  ) +
  theme_minimal() +
  xlim(0,100)

m2 <- ggplot(max_iteration_tsp76, aes(x = PARAMETR, y = WYNIK)) +
  geom_line(colour = "pink", size = 1) +
  labs(
    title = "TSP_76",
    x = "Liczba iteracji",
    y = "Długość ścieżki"
  ) +
  theme_minimal() +
  xlim(0,100)

m3 <- ggplot(max_iteration_tsp127, aes(x = PARAMETR, y = WYNIK)) +
  geom_line(colour = "pink", size = 1) +
  labs(
    title = "TSP_127",
    x = "Liczba iteracji",
    y = "Długość ścieżki"
  ) +
  theme_minimal() +
  xlim(0,100)



(m1 + m2 + m3) +
  plot_layout(guides = "collect", ncol = 2) +  
  plot_annotation(title = "Długość ścieżki w zależności od liczby iteracji")
```

Na powyższych wykresach widzimy zależność długości ścieżki od liczby iteracji. Od razu widzimy, że w każdym przypadku wraz ze wzrostem iteracji, maleje długość ścieżki. Jednak w pewnym momencie dla każdego TSP pojawia się stała wartość, poniżej której algorytm już nie schodzi. Jest to logiczne, ponieważ algorytm nie jest w stanie bez końca szukać lepszego rozwiązania. Jest ich skończona ilość. Liczba iteracji jest różna w zależności od TSP. Dla TSP_48 jest to ok. 20 iteracji, dla TSP_76 - ok. 65 iteracji, a dla TSP_127 - ok. 45 iteracji. Zatem liczba miast nie wpływa na to po jakiej liczbie iteracji otrzymamy najlepszy wynik.

```{r, echo=FALSE}
mi_st48 <- describe(max_iteration_tsp48$WYNIK)
mi_st76 <- describe(max_iteration_tsp76$WYNIK)
mi_st127 <- describe(max_iteration_tsp127$WYNIK)
mi_st <- rbind(mi_st48)
mi_st <- rbind(mi_st, mi_st76)
mi_st <- rbind(mi_st, mi_st127)
mi_st <- mi_st[ ,c("min", "max", "mean")]
rownames(mi_st) <- c("TSP_48", "TSP_76", "TSP_127")
mi_st
```


Zmiana parametru `liczba iteracji` sprawiła, że wyniki są zdecydowanie lepsze w odróżnieniu do solvera i też lepsze niż gdy próbowaliśmy różnego rodzaju ruchy. Uzyskane wyniki są jak narazie najlepsze dla każdego TSP. Średnie są niższe od tych otrzymanych przez solver.


### Liczba restartów

Stałe parametry:

* start_point = 0

* max_time = 500

* max_iteration = 150

```{r, echo=FALSE}
r1 <- ggplot(restart_tsp48, aes(x = PARAMETR, y = WYNIK)) +
  geom_line(colour = "lightblue", size = 1) +
  geom_point(size = 2, position = position_jitter(width = 0.2), colour = "blue") +
  labs(
    title = "TSP_48",
    x = "Liczba restartów",
    y = "Długość ścieżki"
  ) +
  theme_minimal()

r2 <- ggplot(restart_tsp76, aes(x = PARAMETR, y = WYNIK)) +
  geom_line(colour = "lightblue", size = 1) +
  geom_point(size = 2, position = position_jitter(width = 0.2), colour = "blue") +
  labs(
    title = "TSP_76",
    x = "Liczba restartów",
    y = "Długość ścieżki"
  ) +
  theme_minimal()

r3 <- ggplot(restart_tsp127, aes(x = PARAMETR, y = WYNIK)) +
  geom_line(colour = "lightblue", size = 1) +
  geom_point(size = 2, position = position_jitter(width = 0.2), colour = "blue") +
  labs(
    title = "TSP_127",
    x = "Liczba restartów",
    y = "Długość ścieżki"
  ) +
  theme_minimal()


(r1 + r2 + r3) +
  plot_layout(guides = "collect", ncol = 2) +  
  plot_annotation(title = "Długość ścieżki w zależności od liczby restartów")
```

Można zauważyć, że na każdym z wykresów pojawia się tendencja spadkowa długości ścieżki. W różnym stopniu ją widać w zależności od liczby miast, ponieważ wyniki wahają się w dużym stopniu w zależności od liczby restartów. Wahania te zdają się maleć wraz z liczbą restartów, jednak aby to sprawdzić należałoby sprawdzić większą liczbę restartów.


```{r, echo=FALSE}
r_st48 <- describe(restart_tsp48$WYNIK)
r_st76 <- describe(restart_tsp76$WYNIK)
r_st127 <- describe(restart_tsp127$WYNIK)
r_st <- rbind(r_st48)
r_st <- rbind(r_st, r_st76)
r_st <- rbind(r_st, r_st127)
r_st <- r_st[ ,c("min", "max", "mean", "sd")]
rownames(r_st) <- c("TSP_48", "TSP_76", "TSP_127")
r_st
```

Ten parametr zdecydowanie polepszył wyniki. Są one lepsze niż w przypadku `liczby iteracji`. Średnie też są niższe. Wartość odchylenia mówi nam, że jednak wartości te bardzo nie odbiegają od średniej.

### Punkt początkowy

Stałe parametry:

* max_time = 500

* random_restart = 1

* max_iteration = 150

```{r, echo=FALSE}
pt1 <- ggplot(point_tsp48, aes(x = reorder(factor(PARAMETR), -WYNIK), y = WYNIK, fill = factor(PARAMETR))) +
  geom_col() +
  geom_text(aes(label = round(WYNIK,2)), vjust = 2, color = "black", size = 4) + 
  labs(
    title = "TSP_48",
    x = "Punkt początkowy",
    y = "Długość ścieżki",
    fill = "Punkt pocz."
  ) +
  theme_minimal()

pt2 <- ggplot(point_tsp76, aes(x = reorder(factor(PARAMETR), -WYNIK), y = WYNIK, fill = factor(PARAMETR))) +
  geom_col() +
  geom_text(aes(label = round(WYNIK,2)), vjust = 2, color = "black", size = 4) + 
  labs(
    title = "TSP_76",
    x = "Punkt początkowy",
    y = "Długość ścieżki",
    fill = "Punkt pocz."
  ) +
  theme_minimal()

pt3 <- ggplot(point_tsp127, aes(x = reorder(factor(PARAMETR), -WYNIK), y = WYNIK, fill = factor(PARAMETR))) +
  geom_col() +
  geom_text(aes(label = round(WYNIK,2)), vjust = 2, color = "black", size = 4) + 
  labs(
    title = "TSP_127",
    x = "Punkt początkowy",
    y = "Długość ścieżki",
    fill = "Punkt pocz."
  ) +
  theme_minimal()
```

```{r, echo=FALSE}
pt1
```
```{r,echo=FALSE}
pt2
```
```{r, echo=FALSE}
pt3
```

Wylosowany punkt początkowy nie wpływa znacząco na długość ścieżki. Jeżeli punkt został dobrze trafiony to długość jest mniejsza jak dla TSP_48 i punktu startowego 11.

```{r, echo=FALSE}
pt_st48 <- describe(point_tsp48$WYNIK)
pt_st76 <- describe(point_tsp76$WYNIK)
pt_st127 <- describe(point_tsp127$WYNIK)
pt_st <- rbind(pt_st48)
pt_st <- rbind(pt_st, r_st76)
pt_st <- rbind(pt_st, r_st127)
pt_st <- pt_st[ ,c("min", "max", "mean")]
rownames(pt_st) <- c("TSP_48", "TSP_76", "TSP_127")
pt_st
```

Uzyskana długość ścieżki jest najniższa dla TSP_48. Widocznie wylosowany punkt został dobrze trafiony. Dla pozostałych TSP minimalna długość ścieżki jest taka sama jak ta osiągnięta przy zmianie wartości parametru restartu.

## Podsumowanie

Wyniki otrzymane poprzez zmianę poszczególnych parametrów są zdecydowanie lepsze niż te uzyskane przez Solver. Szczególnie zmiana parametru `liczba restartów` zaprezentowała ciekawe wyniki. Przy stałych pozostałych parametrach: start_point = 0, max_time = 500s, max_iteration = 150 osiągnieto przy jego zmianie najlepsze wyniki równe:

```{r, echo=FALSE}
r_st[,c(1,3)]
```

* Dla TSP_48 najniższy wynik został uzyskany pierwszy raz przy 5 restartach i wyniósł on: **10749**.

* Dla TSP_76 najniższy wynik został uzyskany pierwszy raz przy 5 restartach i wyniósł on: **109401.8**

* Dla TSP_127 najniższy wynik został uzyskany pierwszy raz przy 12 restartach i wyniósł on: **119375.3**

# Algorytm wspinaczki z multistartem (IHC)

# ALgorytm symulowanego wyżarzania (SA)

# Algorytm Tabu

# Algorytm genetyczny

# Algorytm zachłanny

Tutaj opisać

```{r}
zachlany_klasyka <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/Zachłanny.xlsx", 
    sheet = "Klasyka")
zachlany_wszystkie <- read_excel("C:/Users/Justyna/source/repos/Projekt_IO/TSP-problem/Zachłanny.xlsx", 
    sheet = "Wszytskie")
```

```{r}
zachlany_klasyka
rownames(zachlany_klasyka) <- c("TSP_48", "TSP_76", "TSP_127")
zachlany_klasyka
```



